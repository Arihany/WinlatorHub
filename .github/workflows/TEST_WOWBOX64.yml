name: Build wowbox64.dll (upstream-style, hardened)

on:
  workflow_dispatch:
    inputs:
      llvm_mingw_version:
        description: llvm-mingw release tag (e.g. 20250430)
        required: false
        default: '20250430'

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  wowbox64:
    name: Build upstream wowbox64.dll only and package WCP (as-is)
    runs-on: ubuntu-22.04 # match the llvm-mingw artifact we download
    timeout-minutes: 60
    env:
      LLVM_MINGW_VERSION: ${{ inputs.llvm_mingw_version }}
      BOX64_PLATFORM_MACRO: -DWOW64=1 -DARM_DYNAREC=1
    steps:
      - name: Install dependencies
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update -yq
          sudo apt-get install -yq --no-install-recommends \
            git cmake make \
            curl ca-certificates xz-utils file \
            gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
            binutils zstd

      - name: Download llvm-mingw (x86_64 host) and expose on PATH
        id: toolchain
        shell: bash
        run: |
          set -Eeuo pipefail
          url="https://github.com/mstorsjo/llvm-mingw/releases/download/${LLVM_MINGW_VERSION}/llvm-mingw-${LLVM_MINGW_VERSION}-ucrt-ubuntu-22.04-x86_64.tar.xz"
          echo "Downloading: $url"
          curl -fSLo llvm-mingw.tar.xz "$url"

          TOOLCHAIN_DIR="$PWD/llvm-mingw-root"
          mkdir -p "$TOOLCHAIN_DIR"
          tar -xf llvm-mingw.tar.xz -C "$TOOLCHAIN_DIR" --strip-components=1

          [ -d "$TOOLCHAIN_DIR/bin" ] || { echo "::error::No bin directory in $TOOLCHAIN_DIR"; ls -la "$TOOLCHAIN_DIR"; exit 1; }
          echo "$TOOLCHAIN_DIR/bin" >> "$GITHUB_PATH"
          echo "LLVM_MINGW_ROOT=$TOOLCHAIN_DIR" >> "$GITHUB_ENV"
          echo "== llvm-mingw bin listing =="; ls -la "$TOOLCHAIN_DIR/bin" | sed -n '1,200p'

      - name: Sanity-check llvm-mingw presence
        shell: bash
        run: |
          set -Eeuo pipefail
          which clang || true
          which aarch64-w64-mingw32-clang || true
          which llvm-rc || true
          which windres || true
          clang --version || true
          aarch64-w64-mingw32-clang --version || true

      - name: Checkout upstream Box64 (pin v0.3.6+ where WowBox64 exists)
        uses: actions/checkout@v4
        with:
          repository: ptitSeb/box64
          ref: v0.3.6
          fetch-depth: 1
          submodules: recursive

      - name: Record commit info
        id: git
        shell: bash
        run: |
          set -Eeuo pipefail
          SHA=$(git rev-parse HEAD)
          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "short=${SHA:0:7}" >> $GITHUB_OUTPUT

      - name: Configure top-level (Linux target) per upstream style
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
            -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
            ${BOX64_PLATFORM_MACRO} \
            -DWOWBOX64=1 \
            -DLLVM_MINGW_ROOT="$LLVM_MINGW_ROOT" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON

      - name: Show CMake cache and available targets
        shell: bash
        working-directory: build
        run: |
          set -Eeuo pipefail
          echo '== Grep WOW/WINE/MINGW from CMakeCache.txt =='
          grep -Ei 'WOW|WINE|MINGW' CMakeCache.txt || true
          echo '== Writing --target help to help.txt (avoid broken pipe) =='
          cmake --build . --target help > help.txt || true
          echo '== First 200 lines of help.txt =='
          sed -n '1,200p' help.txt || true

      - name: Ensure llvm-mingw present (post-checkout)
        shell: bash
        run: |
          set -Eeuo pipefail
          if [ -n "${LLVM_MINGW_ROOT:-}" ] && [ -d "${LLVM_MINGW_ROOT}/bin" ]; then
            echo "llvm-mingw already present at $LLVM_MINGW_ROOT"
          else
            echo "Re-acquiring llvm-mingw into RUNNER_TEMP due to workspace cleanup"
            url="https://github.com/mstorsjo/llvm-mingw/releases/download/${LLVM_MINGW_VERSION}/llvm-mingw-${LLVM_MINGW_VERSION}-ucrt-ubuntu-22.04-x86_64.tar.xz"
            echo "Downloading: $url"
            mkdir -p "$RUNNER_TEMP/llvm-mingw-root"
            curl -fSLo "$RUNNER_TEMP/llvm-mingw.tar.xz" "$url"
            tar -xf "$RUNNER_TEMP/llvm-mingw.tar.xz" -C "$RUNNER_TEMP/llvm-mingw-root" --strip-components=1
            echo "LLVM_MINGW_ROOT=$RUNNER_TEMP/llvm-mingw-root" >> "$GITHUB_ENV"
            echo "$RUNNER_TEMP/llvm-mingw-root/bin" >> "$GITHUB_PATH"
          fi
          ls -la "${LLVM_MINGW_ROOT}/bin" | sed -n '1,80p'

      - name: Prepare env for external mingw build
        shell: bash
        run: |
          set -Eeuo pipefail
          MINGW_BIN="$LLVM_MINGW_ROOT/bin"
          echo "MINGW_BIN=$MINGW_BIN"
          ls -la "$MINGW_BIN" | sed -n '1,80p'
          command -v "$MINGW_BIN/aarch64-w64-mingw32-clang" || true
          # Export full-path compilers so ExternalProject cmake sees absolute paths
          {
            echo "CC=$MINGW_BIN/aarch64-w64-mingw32-clang"
            echo "CXX=$MINGW_BIN/aarch64-w64-mingw32-clang++"
            echo "ASM=$MINGW_BIN/aarch64-w64-mingw32-clang"
            echo "RC=$MINGW_BIN/llvm-rc"
            echo "AR=$MINGW_BIN/llvm-ar"
            echo "NM=$MINGW_BIN/llvm-nm"
            echo "RANLIB=$MINGW_BIN/llvm-ranlib"
            echo "STRIP=$MINGW_BIN/llvm-strip"
          } >> "$GITHUB_ENV"

      - name: Build wowbox64 target (fail if missing)
        shell: bash
        working-directory: build
        run: |
          set -Eeuo pipefail
          if [ ! -f help.txt ]; then
            cmake --build . --target help > help.txt || true
          fi
          if grep -qi "wowbox64" help.txt; then
            echo '== Using mingw toolchain (from $CC/$CXX/ASM) =='
            echo "CC=$CC"; echo "CXX=$CXX"; echo "ASM=$ASM"; echo "RC=$RC"
            env | grep -E '^(CC|CXX|ASM|RC|AR|NM|RANLIB|STRIP)='
            cmake --build . --target wowbox64 -- -j"$(nproc)"
          else
            echo "::group::Debug: help.txt (first 200 lines)"
            sed -n '1,200p' help.txt || true
            echo "::endgroup::"
            echo "::error::CMake target 'wowbox64' not found.
			Hints:
			- Ensure checkout is on v0.3.6+
			- Ensure llvm-mingw tools are in PATH before configure (aarch64-w64-mingw32-clang/llvm-rc)
			- See the previous step logs."
						exit 1
          fi
          if grep -qi "wowbox64" help.txt; then
            cmake --build . --target wowbox64 -- -j"$(nproc)"
          else
            echo "::group::Debug: help.txt (first 200 lines)"
            sed -n '1,200p' help.txt || true
            echo "::endgroup::"
            echo "::error::CMake target 'wowbox64' not found.
			Hints:
			- Ensure checkout is on v0.3.6+
			- Ensure llvm-mingw tools are in PATH before configure (aarch64-w64-mingw32-clang/llvm-rc)
			- See the previous step logs."
						exit 1
					  fi

      - name: Locate and verify wowbox64.dll (ExternalProject output)
        id: out
        shell: bash
        run: |
          set -Eeuo pipefail
          CANDIDATE="build/wowbox64-prefix/src/wowbox64-build/wowbox64.dll"
          if [ -f "$CANDIDATE" ]; then
            DLL="$CANDIDATE"
          else
            DLL=$(find build -type f -iname 'wowbox64.dll' | head -n1 || true)
          fi
          if [ -z "$DLL" ]; then
            echo "::error::wowbox64.dll not produced"; exit 1
          fi
          file "$DLL"
          objdump -p "$DLL" | grep -qi 'machine.*ARM64' || { echo "::error::Expected ARM64 PE"; exit 1; }
          echo "dll=$DLL" >> "$GITHUB_OUTPUT"

      - name: Decide date code (YYMMDD, KST)
        id: date
        shell: bash
        run: echo "code=$(TZ=Asia/Seoul date +%y%m%d)" >> $GITHUB_OUTPUT

      # WCP packaging: kept EXACTLY as provided (no edits)
      - name: Package WCP (WowBox64)
        id: wcp
        env:
          DATECODE: ${{ steps.date.outputs.code }}
          SHORT:    ${{ steps.git.outputs.short }}
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p out
          cp "${{ steps.out.outputs.dll }}" wowbox64.dll
          # Unquoted heredoc so SHORT/DATECODE expand; keep ${syswow64} literal via backslash.
          cat > profile.json <<EOF
          {
            "type": "WOWBox64",
            "versionName": "nightly-${SHORT}",
            "versionCode": ${DATECODE},
            "description": "${DATECODE} WowBox64 Build by Ari",
            "files": [
              { "source": "wowbox64.dll", "target": "\${syswow64}/wowbox64.dll" }
            ]
          }
          EOF
          tar --zstd --format=gnu --owner=0 --group=0 --numeric-owner --sort=name \
            -cf "out/wowbox64-nightly-${DATECODE}.wcp" profile.json wowbox64.dll
          echo "wcp=out/wowbox64-nightly-${DATECODE}.wcp" >> $GITHUB_OUTPUT

      - name: Upload WCP artifact
        uses: actions/upload-artifact@v4
        with:
          name: wowbox64-nightly-${{ steps.date.outputs.code }}.wcp
          path: ${{ steps.wcp.outputs.wcp }}
          if-no-files-found: error

      - name: Upload bare DLL artifact (for quick testing)
        uses: actions/upload-artifact@v4
        with:
          name: wowbox64-${{ steps.date.outputs.code }}.dll
          path: ${{ steps.out.outputs.dll }}
          if-no-files-found: error
