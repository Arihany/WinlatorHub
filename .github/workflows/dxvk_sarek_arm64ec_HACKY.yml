name: build-dxvk-sarek-arm64ec hh

on:
  workflow_dispatch:

env:
  # Upstream SAREK repo & fixed ARM64EC toolchain
  UPSTREAM_REPO: pythonlover02/DXVK-Sarek
  TOOLCHAIN_URL: https://github.com/bylaws/llvm-mingw/releases/download/20250305/llvm-mingw-20250305-ucrt-ubuntu-20.04-x86_64.tar.xz

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout this repo (workflow)
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ninja-build meson python3 \
            glslang-tools ca-certificates curl xz-utils \
            pkgconf jq git

      - name: Resolve latest release tag on 'main' (upstream)
        id: rel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          api="https://api.github.com/repos/${{ env.UPSTREAM_REPO }}"
          # Prefer the most recent published release that targets 'main'
          tag=$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28" "$api/releases" \
            | jq -r '[.[] | select(.draft==false and .prerelease==false and .target_commitish=="main")] 
                      | (max_by(.created_at//.published_at) | .tag_name) // ""')
          if [ -z "$tag" ]; then
            # Fallback to 'latest'
            tag=$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28" "$api/releases/latest" \
              | jq -r '.tag_name // ""')
          fi
          [ -n "$tag" ] || { echo "::error::Failed to resolve a release tag for ${{ env.UPSTREAM_REPO }}"; exit 1; }
          echo "Resolved tag: $tag"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Checkout upstream DXVK-Sarek (release tag)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ steps.rel.outputs.tag }}
          submodules: recursive
          fetch-depth: 0
          path: dxvk

      - name: Download ARM64EC llvm-mingw toolchain (bylaws)
        run: |
          set -euo pipefail
          mkdir -p "$HOME/toolchain"
          curl -L "${{ env.TOOLCHAIN_URL }}" -o /tmp/llvm-mingw.tar.xz
          tar -xJf /tmp/llvm-mingw.tar.xz -C "$HOME/toolchain" --strip-components=1
          echo "$HOME/toolchain/bin" >> "$GITHUB_PATH"

      - name: Show toolchain info + dump macros (baseline)
        run: |
          set -euo pipefail
          which arm64ec-w64-mingw32-g++
          arm64ec-w64-mingw32-g++ --version
          echo '== Predefined macros (baseline) =='
          arm64ec-w64-mingw32-g++ -dM -E - < /dev/null | \
            egrep -E '__arm64ec__|_M_ARM64EC|__aarch64__|__x86_64__|_M_X64|_M_AMD64' || true
          echo '== Include search paths =='
          arm64ec-w64-mingw32-g++ -v -E -x c++ /dev/null || true

      - name: Generate Meson cross file for ARM64EC
        working-directory: dxvk
        run: |
          set -euo pipefail
          cat > arm64ec.meson <<'EOF'
          [binaries]
          ar = 'arm64ec-w64-mingw32-ar'
          c = 'arm64ec-w64-mingw32-gcc'
          cpp = 'arm64ec-w64-mingw32-g++'
          ld = 'arm64ec-w64-mingw32-ld'
          windres = 'arm64ec-w64-mingw32-windres'
          widl = 'arm64ec-w64-mingw32-widl'
          strip = 'llvm-strip'
      
          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
      
          [built-in options]
          # SSE/AVX 매크로는 정의하지 않는다!!
          c_args  = ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1']
          cpp_args= ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1']
          EOF
          echo "== arm64ec.meson ==" && nl -ba arm64ec.meson

      # --- SAREK-SPECIFIC PATCH (ARM64EC SSE shim) ---
      - name: Patch SAREK headers to avoid x86 intrinsics on ARM64EC (shim)
        working-directory: dxvk
        shell: bash
        run: |
          set -euo pipefail
      
          # 0) ARM64EC 전용 SSE 폴리필 헤더 생성 (최소 필요 집합)
          mkdir -p include
          cat > include/sarek_arm64ec_sse_shim.h <<'SHIM'
          #pragma once
          #if (defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC))
          #include <cstdint>
          #include <cstring>
          struct alignas(16) __m128  { float   v[4];  };
          struct alignas(16) __m128i { uint8_t v[16]; };
          static inline void _mm_pause(void) {
            #if defined(__aarch64__) || defined(__arm64ec__) || defined(_M_ARM64EC)
              #if defined(__has_builtin)
                #if __has_builtin(__builtin_arm_yield)
                  __builtin_arm_yield(); return;
                #elif __has_builtin(__builtin_aarch64_yield)
                  __builtin_aarch64_yield(); return;
                #endif
              #endif
              __asm__ __volatile__("yield" ::: "memory");
            #else
              __asm__ __volatile__("" ::: "memory");
            #endif
          }
          static inline __m128 _mm_loadu_ps(const float* p){ __m128 r; std::memcpy(r.v,p,16); return r; }
          static inline void   _mm_storeu_ps(float* p,const __m128& a){ std::memcpy(p,a.v,16); }
          static inline __m128 _mm_cmpeq_ps(const __m128& a,const __m128& b){
            __m128 r; for(int i=0;i<4;i++){ uint32_t m=(a.v[i]==b.v[i])?0xFFFFFFFFu:0u; std::memcpy(&r.v[i],&m,4);} return r;
          }
          static inline __m128 _mm_and_ps(const __m128& a,const __m128& b){
            __m128 r; for(int i=0;i<4;i++){ uint32_t ai,bi,ci; std::memcpy(&ai,&a.v[i],4); std::memcpy(&bi,&b.v[i],4); ci=ai&bi; std::memcpy(&r.v[i],&ci,4);} return r;
          }
          static inline __m128i _mm_setzero_si128(){ __m128i r; std::memset(r.v,0,16); return r; }
          static inline __m128i _mm_set1_epi8(int x){ __m128i r; uint8_t v=(uint8_t)x; for(int i=0;i<16;i++) r.v[i]=v; return r; }
          static inline __m128i _mm_load_si128(const __m128i* p){ __m128i r; std::memcpy(&r,p,16); return r; }
          static inline __m128i _mm_loadu_si128(const __m128i* p){ return _mm_load_si128(p); }
          static inline void     _mm_store_si128(__m128i* p, const __m128i& a){ std::memcpy(p,&a,16); }
          static inline void     _mm_storeu_si128(__m128i* p, const __m128i& a){ _mm_store_si128(p,a); }
          static inline __m128i _mm_cmpeq_epi8(const __m128i& a,const __m128i& b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=(a.v[i]==b.v[i])?0xFF:0x00; return r; }
          static inline __m128i _mm_and_si128(const __m128i& a,const __m128i& b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=a.v[i]&b.v[i]; return r; }
          static inline __m128i _mm_or_si128 (const __m128i& a,const __m128i& b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=a.v[i]|b.v[i]; return r; }
          static inline __m128i _mm_xor_si128(const __m128i& a,const __m128i& b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=a.v[i]^b.v[i]; return r; }
          static inline int _mm_movemask_epi8(const __m128i& a){ int m=0; for(int i=0;i<16;i++) m|=((a.v[i]&0x80)?1:0)<<i; return m; }
          #endif
          SHIM
      
          # 1) util_vector.h / util_bit.h 상단에 ARM64EC 프로로그 + shim include (중복 방지)
          ARM64EC_PROLOG='#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)
          /* SAREK on ARM64EC: disable x86/SSE/AVX paths + provide SSE shim */
          #undef __x86_64__
          #undef _M_X64
          #undef _M_AMD64
          #undef __i386__
          #undef _M_IX86
          #undef __SSE__
          #undef __SSE2__
          #undef __SSE3__
          #undef __SSSE3__
          #undef __SSE4_1__
          #undef __SSE4_2__
          #undef __AVX__
          #undef __AVX2__
          #include "sarek_arm64ec_sse_shim.h"
          #endif
          '
          for f in src/util/util_vector.h src/util/util_bit.h; do
            if [ -f "$f" ] && ! grep -q 'SAREK on ARM64EC: disable x86/SSE/AVX paths' "$f"; then
              echo "Injecting ARM64EC prolog + shim into: $f"
              tmp=$(mktemp)
              printf "%s\n" "$ARM64EC_PROLOG" > "$tmp"
              cat "$f" >> "$tmp"
              mv "$tmp" "$f"
            fi
          done

          # 2-bis) sync_spinlock.h도 shim을 직접 include (idempotent)
          if [ -f src/util/sync/sync_spinlock.h ]; then
            if ! grep -q 'sarek_arm64ec_sse_shim.h' src/util/sync/sync_spinlock.h; then
              echo "Prepending shim include to src/util/sync/sync_spinlock.h"
              tmp=$(mktemp)
              {
                echo '#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)'
                echo '#include "sarek_arm64ec_sse_shim.h"'
                echo '#endif'
                cat src/util/sync/sync_spinlock.h
              } > "$tmp"
              mv "$tmp" src/util/sync/sync_spinlock.h
            else
              echo "sync_spinlock.h already includes shim (ok)"
            fi
          else
            echo "warn: src/util/sync/sync_spinlock.h not found (skipped)"
          fi

          # 2-ter) util_bit.h의 x86 asm(bsf/cmovz) 블록을 ARM64EC 전용 빌트인으로 포괄 치환
          python3 - <<'PY'
          import re, pathlib, sys
          p = pathlib.Path("src/util/util_bit.h")
          s = p.read_text(encoding="utf-8", errors="ignore")

          # asm(...) 전체 블록을 잡되, 내용에 bsf/cmovz가 들어간 것만 치환
          pat = re.compile(r'(?P<asm>(?:__asm__|asm)\s*(?:volatile\s*)?\(.*?\)\s*;)', re.IGNORECASE | re.DOTALL)
          replaced = 0

          def wrap(m):
              global replaced  # <-- nonlocal 대신 global
              block = m.group('asm')
              low = block.lower()
              if 'bsf' in low or 'cmovz' in low:
                  replaced += 1
                  return (
                      "#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)\n"
                      "      /* SAREK ARM64EC: replace x86 asm (bsf/cmovz) with builtin */\n"
                      "      /* Assumes local vars: res,tmp,n (matches original block) */\n"
                      "      res = (n ? __builtin_ctz((unsigned)n) : 32);\n"
                      "      tmp = 0;\n"
                      "#else\n" + block + "\n#endif\n"
                  )
              return block

          ns = pat.sub(wrap, s)
          if replaced == 0:
              print('error: could not find x86 asm block with bsf/cmovz to replace in util_bit.h', file=sys.stderr)
              print('\n'.join(s.splitlines()[:160]))
              sys.exit(1)
          p.write_text(ns, encoding="utf-8")
          print(f'patched util_bit.h: replaced {replaced} asm block(s)')
          PY

          # 변경 확인(문맥 출력)
          nl -ba src/util/util_bit.h | sed -n '60,160p' || true

          # --- ARM64EC 정의를 넣고 전처리 결과에서만 x86 asm(bsf) 존재 여부를 검사 ---
          CXX=arm64ec-w64-mingw32-g++
          BASE="-std=c++17 -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 -D_FILE_OFFSET_BITS=64 -D_WIN32_WINNT=0x0A00 -DDXVK_WSI_WIN32 -I. -Isrc -Iinclude"

          echo '#include "src/util/util_bit.h"' > __pp_probe.cpp
          $CXX -E -x c++ -P $BASE __pp_probe.cpp > __pp_probe.i || true

          # 전처리 결과에 여전히 asm(...bsf...)가 남아있다면 실패
          if grep -qE '(^|[^A-Za-z_])(asm|__asm__)\s*\([^;]*bsf' __pp_probe.i; then
            echo "::error:: Preprocessed output still contains x86 asm bsf under SAREK_ARM64EC"
            tail -n 200 __pp_probe.i || true
            exit 1
          fi
      
          # 2) DXVK 자체 소스 목록(서드파티 제외)
          find src include -type f \( -name '*.h' -o -name '*.hpp' -o -name '*.c' -o -name '*.cpp' -o -name '*.inl' \) \
            -not -path 'include/vulkan/*' -not -path 'include/spirv/*' > __filelist.txt
      
          # 3) x86 전용 인트린식 include 라인 주석화 (intrin.h 는 유지)
          mapfile -t KILL_HDRS < <(
            xargs -a __filelist.txt grep -RInE \
              '#\s*include\s*[<"]\s*(x86intrin|x86gprintrin|immintrin)\.h\s*[>"]' 2>/dev/null \
            | cut -d: -f1 | sort -u
          )
          for f in "${KILL_HDRS[@]:-}"; do
            echo "Neutralizing x86 intrinsics includes in: $f"
            sed -i -E '/SAREK_ARM64EC neutralized/! s@(^\s*#\s*include\s*[<"](x86intrin|x86gprintrin|immintrin)\.h[>"])@/* SAREK_ARM64EC neutralized */ // \1@' "$f"
          done
      
          # 4) x86 감지 조건에 ARM64EC 제외
          mapfile -t COND_FILES < <(
            xargs -a __filelist.txt grep -RIl -E \
              'defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)' 2>/dev/null
          )
          for f in "${COND_FILES[@]:-}"; do
            echo "Patching arch guards in: $f"
            sed -i -E '/defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)/{
              /SAREK_ARM64EC|__arm64ec__|_M_ARM64EC/! s@defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)@defined(\1) \&\& !defined(SAREK_ARM64EC) \&\& !defined(__arm64ec__) \&\& !defined(_M_ARM64EC)@g
            }' "$f"
          done
      
          # 5) 컴파일러 기반 검증: 대표 TU 전처리 스캔 (-H 또는 deps)
          CXX=arm64ec-w64-mingw32-g++
          BASE="-std=c++17 -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 -D_FILE_OFFSET_BITS=64 -D_WIN32_WINNT=0x0A00 -DDXVK_WSI_WIN32 -I. -Isrc -Iinclude"
      
          cat > __inc_test.cpp <<'INC'
          #include "src/util/util_bit.h"
          #include "src/util/util_vector.h"
          INC
      
          : > __inc_tree_all.log
          find src -type f -name '*.cpp' | sort | head -n 20 > __probe_files.txt || true
          PROBES=(__inc_test.cpp)
          if [ -s __probe_files.txt ]; then
            mapfile -t more < __probe_files.txt
            PROBES+=("${more[@]}")
          fi
      
          HAD_H=false
          if $CXX -E -x c++ -H $BASE __inc_test.cpp -o /dev/null &>> __inc_tree_all.log; then
            HAD_H=true
          fi
          for tu in "${PROBES[@]}"; do
            $CXX -E -x c++ -H $BASE "$tu" -o /dev/null &>> __inc_tree_all.log || true
          done
      
          if grep -qE '/(x86intrin|immintrin)\.h' __inc_tree_all.log; then
            echo "== Include tree tail ==" && tail -n 200 __inc_tree_all.log || true
            echo "::error:: x86-only intrinsics headers still included"
            exit 1
          fi
      
          if [ "$HAD_H" = false ]; then
            echo "note: -H unsupported or failed, using dependency scan fallback..."
            : > __inc_deps_all.txt
            for tu in "${PROBES[@]}"; do
              $CXX -fsyntax-only -MMD -MF __tmp.d -MP -MT dummy $BASE "$tu" 2>> __inc_dep_err.log || true
              [ -f __tmp.d ] && cat __tmp.d >> __inc_deps_all.txt || true
              rm -f __tmp.d || true
            done
            if grep -qE '(x86intrin|immintrin)\.h' __inc_deps_all.txt; then
              echo "::error:: Deps show x86-only intrinsics headers getting pulled"
              exit 1
            fi
          fi
      
          echo "== Head of src/util/util_bit.h (after patch) =="
          head -n 60 src/util/util_bit.h || true

          # 2-quater) D3D9 devinfo 타입명 호환 레이어 (llvm-mingw 헤더와 이름차 보정)
          # 타입은 매크로가 아니라서 #ifdef로 존재 여부 확인 불가 → 그냥 옛 이름을 새 이름으로 매핑
          cat > include/sarek_d3d9_compat.h <<'HDR'
          #pragma once
          #if defined(__has_include)
          # if __has_include(<d3d9.h>)
          #  include <d3d9.h>
          # endif
          #endif
          
          /* Old SDK → mingw-w64 이름 매핑 (무조건 매핑, 이미 정의돼 있으면 매크로가 덮어씌워짐) */
          #ifndef D3DDEVINFO_RESOURCEMANAGER
          #define D3DDEVINFO_RESOURCEMANAGER D3DDEVINFO_D3DRESOURCEMANAGER
          #endif
          
          #ifndef D3DDEVINFO_VERTEXSTATS
          #define D3DDEVINFO_VERTEXSTATS D3DDEVINFO_D3DVERTEXSTATS
          #endif
          HDR
          
          # d3d9 공용 인클루드에 호환 헤더를 한 줄 삽입(중복 방지). 로컬 헤더 탐색을 확실히 하려고 따옴표 사용.
          if [ -f src/d3d9/d3d9_include.h ]; then
            if ! grep -q 'sarek_d3d9_compat.h' src/d3d9/d3d9_include.h; then
              echo "Prepending D3D9 compat include to src/d3d9/d3d9_include.h"
              tmp=$(mktemp)
              { echo '#include "sarek_d3d9_compat.h"'; cat src/d3d9/d3d9_include.h; } > "$tmp"
              mv "$tmp" src/d3d9/d3d9_include.h
            else
              # 예전에 <...>로 들어갔을 수도 있으니 첫 부분만 "..."로 교체
              sed -i '1,16{s|#include <sarek_d3d9_compat.h>|#include "sarek_d3d9_compat.h"|}' src/d3d9/d3d9_include.h || true
            fi
          fi

      - name: Wipe build dir (idempotent & -e safe)
        working-directory: dxvk
        shell: bash
        run: |
          if [ -d build.w64 ]; then
            rm -rf build.w64
            echo "Removed build.w64"
          else
            echo "No build.w64 (ok)"
          fi
          if [ -d install ]; then
            rm -rf install
            echo "Removed install"
          else
            echo "No install (ok)"
          fi

      - name: "Preflight: meson.build presence"
        working-directory: dxvk
        run: |
          set -euo pipefail
          test -f meson.build || { echo "::error::meson.build not found in $PWD"; ls -la; exit 1; }

      - name: Configure (Meson)
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson setup build.w64 . --cross-file arm64ec.meson --buildtype release --prefix "$PWD/install"
          meson configure build.w64
          echo '== Meson build options (excerpt) =='
          meson introspect build.w64 --buildoptions | head -n 120 || true

      - name: Macro snapshot after configure (with injected defines)
        working-directory: dxvk
        run: |
          set -euo pipefail
          echo '== Predefined macros (+ our -D) =='
          arm64ec-w64-mingw32-g++ -dM -E -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 - < /dev/null | \
            egrep -E 'SAREK_ARM64EC|__CRT__NO_INLINE|__arm64ec__|_M_ARM64EC|__aarch64__|__x86_64__|_M_X64|_M_AMD64|__SSE__|__AVX__' || true

      - name: Build
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson compile -C build.w64 -v

      - name: Install into staging dir
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson install -C build.w64

      - name: Upload DLL artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-dlls
          path: |
            dxvk/install/bin/*.dll
            dxvk/install/bin/*.pdb
          if-no-files-found: error

      - name: Upload build logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-logs
          path: |
            dxvk/build.w64/meson-logs/**
            dxvk/build.w64/meson-info/**
            dxvk/meson-logs/**
            dxvk/arm64ec.meson
            dxvk/__inc_tree_all.log
            dxvk/__inc_dep_err.log
            dxvk/__inc_deps_all.txt
          if-no-files-found: warn
