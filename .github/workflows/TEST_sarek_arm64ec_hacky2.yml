name: TEST sarek arm64 hacky2

on:
  workflow_dispatch:

env:
  # Upstream SAREK repo & fixed ARM64EC toolchain
  UPSTREAM_REPO: pythonlover02/DXVK-Sarek
  TOOLCHAIN_URL: https://github.com/bylaws/llvm-mingw/releases/download/20250305/llvm-mingw-20250305-ucrt-ubuntu-20.04-x86_64.tar.xz

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout this repo (workflow)
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ninja-build meson python3 \
            glslang-tools ca-certificates curl xz-utils \
            pkgconf jq git

      - name: Resolve latest release tag on 'main' (upstream)
        id: rel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          api="https://api.github.com/repos/${{ env.UPSTREAM_REPO }}"
          # Prefer the most recent published release that targets 'main'
          tag=$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28" "$api/releases" \
            | jq -r '[.[] | select(.draft==false and .prerelease==false and .target_commitish=="main")] 
                      | (max_by(.created_at//.published_at) | .tag_name) // ""')
          if [ -z "$tag" ]; then
            # Fallback to 'latest'
            tag=$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28" "$api/releases/latest" \
              | jq -r '.tag_name // ""')
          fi
          [ -n "$tag" ] || { echo "::error::Failed to resolve a release tag for ${{ env.UPSTREAM_REPO }}"; exit 1; }
          echo "Resolved tag: $tag"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Checkout upstream DXVK-Sarek (release tag)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ steps.rel.outputs.tag }}
          submodules: recursive
          fetch-depth: 0
          path: dxvk

      - name: Download ARM64EC llvm-mingw toolchain (bylaws)
        run: |
          set -euo pipefail
          mkdir -p "$HOME/toolchain"
          curl -L "${{ env.TOOLCHAIN_URL }}" -o /tmp/llvm-mingw.tar.xz
          tar -xJf /tmp/llvm-mingw.tar.xz -C "$HOME/toolchain" --strip-components=1
          # Prepend toolchain to PATH for precedence
          echo "PATH=$HOME/toolchain/bin:$PATH" >> "$GITHUB_ENV"
          echo "$HOME/toolchain/bin" >> "$GITHUB_PATH"

      - name: Show toolchain info + dump macros (baseline)
        run: |
          set -euo pipefail
          which arm64ec-w64-mingw32-g++
          arm64ec-w64-mingw32-g++ --version
          echo '== Predefined macros (baseline) =='
          arm64ec-w64-mingw32-g++ -dM -E - < /dev/null | \
            egrep -E '__arm64ec__|_M_ARM64EC|__aarch64__|__x86_64__|_M_X64|_M_AMD64' || true
          echo '== Include search paths =='
          arm64ec-w64-mingw32-g++ -v -E -x c++ /dev/null || true

      - name: Generate Meson cross file for ARM64EC
        working-directory: dxvk
        run: |
          set -euo pipefail
          cat > arm64ec.meson <<'EOF'
          [binaries]
          ar = 'arm64ec-w64-mingw32-ar'
          c = 'arm64ec-w64-mingw32-gcc'
          cpp = 'arm64ec-w64-mingw32-g++'
          ld = 'arm64ec-w64-mingw32-ld'
          windres = 'arm64ec-w64-mingw32-windres'
          widl = 'arm64ec-w64-mingw32-widl'
          strip = 'llvm-strip'
      
          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
      
          [built-in options]
          # SSE/AVX 매크로는 정의하지 않는다!! + 의미 보존 플래그
          c_args  = ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1','-fno-fast-math','-ffp-contract=off']
          cpp_args= ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1','-fno-fast-math','-ffp-contract=off']
          EOF
          echo "== arm64ec.meson ==" && nl -ba arm64ec.meson

      # --- SAREK-SPECIFIC PATCH (ARM64EC SSE shim v2 + strict gates) ---
      - name: Patch SAREK headers to avoid x86 intrinsics on ARM64EC (shim v2 + strict)
        working-directory: dxvk
        shell: bash
        run: |
          set -euo pipefail
      
          # 0) ARM64EC 전용 SSE 폴리필 헤더 생성 (NEON 우선)
          mkdir -p include
          cat > include/sarek_arm64ec_sse_shim.h <<'SHIM'
          #pragma once
          #if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)

          #include <cstdint>
          #include <cstring>

          #if defined(__aarch64__) || defined(__arm64ec__) || defined(_M_ARM64EC)
            #include <arm_neon.h>
            typedef float32x4_t __m128;
            typedef uint8x16_t  __m128i;

            static inline void _mm_pause(void) { __asm__ __volatile__("yield" ::: "memory"); }
            static inline __m128 _mm_loadu_ps(const float* p){ return vld1q_f32(p); }
            static inline void   _mm_storeu_ps(float* p, __m128 a){ vst1q_f32(p, a); }
            static inline __m128 _mm_cmpeq_ps(__m128 a, __m128 b){
              return vreinterpretq_f32_u32(vceqq_f32(a, b));
            }
            static inline __m128 _mm_and_ps(__m128 a, __m128 b){
              return vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(a), vreinterpretq_u32_f32(b)));
            }
            static inline __m128i _mm_setzero_si128(){ return vdupq_n_u8(0); }
            static inline __m128i _mm_set1_epi8(int x){ return vdupq_n_u8((uint8_t)x); }
            static inline __m128i _mm_load_si128 (const __m128i* p){ return vld1q_u8((const uint8_t*)p); }
            static inline __m128i _mm_loadu_si128(const __m128i* p){ return vld1q_u8((const uint8_t*)p); }
            static inline void     _mm_store_si128 (__m128i* p, __m128i a){ vst1q_u8((uint8_t*)p, a); }
            static inline void     _mm_storeu_si128(__m128i* p, __m128i a){ vst1q_u8((uint8_t*)p, a); }
            static inline __m128i _mm_cmpeq_epi8(__m128i a, __m128i b){ return vceqq_u8(a, b); }
            static inline __m128i _mm_and_si128 (__m128i a, __m128i b){ return vandq_u8(a, b); }
            static inline __m128i _mm_or_si128  (__m128i a, __m128i b){ return vorrq_u8(a, b); }
            static inline __m128i _mm_xor_si128 (__m128i a, __m128i b){ return veorq_u8(a, b); }
            static inline int _mm_movemask_epi8(__m128i a){
              alignas(16) uint8_t tmp[16]; vst1q_u8(tmp, a);
              int m = 0; for(int i=0;i<16;i++) m |= ((tmp[i] & 0x80)?1:0) << i; return m;
            }
          #else
            struct alignas(16) __m128  { float   v[4];  };
            struct alignas(16) __m128i { uint8_t v[16]; };
            static inline void _mm_pause(void){ __asm__ __volatile__("" ::: "memory"); }
            static inline __m128 _mm_loadu_ps(const float* p){ __m128 r; std::memcpy(r.v,p,16); return r; }
            static inline void   _mm_storeu_ps(float* p, __m128 a){ std::memcpy(p,a.v,16); }
            static inline __m128 _mm_cmpeq_ps(__m128 a,__m128 b){
              __m128 r; for(int i=0;i<4;i++){ uint32_t m=(a.v[i]==b.v[i])?0xFFFFFFFFu:0u; std::memcpy(&r.v[i],&m,4);} return r;
            }
            static inline __m128 _mm_and_ps(__m128 a,__m128 b){
              __m128 r; for(int i=0;i<4;i++){ uint32_t ai,bi,ci; std::memcpy(&ai,&a.v[i],4); std::memcpy(&bi,&b.v[i],4); ci=ai&bi; std::memcpy(&r.v[i],&ci,4);} return r;
            }
            static inline __m128i _mm_setzero_si128(){ __m128i r; std::memset(r.v,0,16); return r; }
            static inline __m128i _mm_set1_epi8(int x){ __m128i r; uint8_t v=(uint8_t)x; for(int i=0;i<16;i++) r.v[i]=v; return r; }
            static inline __m128i _mm_load_si128(const __m128i* p){ __m128i r; std::memcpy(&r,p,16); return r; }
            static inline __m128i _mm_loadu_si128(const __m128i* p){ return _mm_load_si128(p); }
            static inline void     _mm_store_si128(__m128i* p, __m128i a){ std::memcpy(p,&a,16); }
            static inline void     _mm_storeu_si128(__m128i* p, __m128i a){ _mm_store_si128(p,a); }
            static inline __m128i _mm_cmpeq_epi8(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=(a.v[i]==b.v[i])?0xFF:0x00; return r; }
            static inline __m128i _mm_and_si128(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=a.v[i]&b.v[i]; return r; }
            static inline __m128i _mm_or_si128 (__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]|=b.v[i]; return r; }
            static inline __m128i _mm_xor_si128(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]^=b.v[i]; return r; }
            static inline int _mm_movemask_epi8(__m128i a){ int m=0; for(int i=0;i<16;i++) m|=((a.v[i]&0x80)?1:0)<<i; return m; }
          #endif

          #if defined(__SSE__) || defined(__SSE2__) || defined(__SSE3__) || defined(__SSSE3__) || \
              defined(__SSE4_1__) || defined(__SSE4_2__) || defined(__AVX__) || defined(__AVX2__)
          #error "x86 SIMD macros must not be defined on ARM64EC build"
          #endif

          #endif
          SHIM
      
          # 1) util_vector.h / util_bit.h 상단에 ARM64EC 프로로그 + shim include (중복 방지)
          ARM64EC_PROLOG='#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)
          /* SAREK on ARM64EC: disable x86/SSE/AVX paths + provide SSE shim */
          #undef __x86_64__
          #undef _M_X64
          #undef _M_AMD64
          #undef __i386__
          #undef _M_IX86
          #undef __SSE__
          #undef __SSE2__
          #undef __SSE3__
          #undef __SSSE3__
          #undef __SSE4_1__
          #undef __SSE4_2__
          #undef __AVX__
          #undef __AVX2__
          #include "sarek_arm64ec_sse_shim.h"
          #endif
          '
          for f in src/util/util_vector.h src/util/util_bit.h; do
            if [ -f "$f" ] && ! grep -q 'SAREK on ARM64EC: disable x86/SSE/AVX paths' "$f"; then
              echo "Injecting ARM64EC prolog + shim into: $f"
              tmp=$(mktemp)
              printf "%s\n" "$ARM64EC_PROLOG" > "$tmp"
              cat "$f" >> "$tmp"
              mv "$tmp" "$f"
            fi
          done

          # 2) sync_spinlock.h도 shim을 직접 include (idempotent)
          if [ -f src/util/sync/sync_spinlock.h ]; then
            if ! grep -q 'sarek_arm64ec_sse_shim.h' src/util/sync/sync_spinlock.h; then
              echo "Prepending shim include to src/util/sync/sync_spinlock.h"
              tmp=$(mktemp)
              {
                echo '#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)'
                echo '#include "sarek_arm64ec_sse_shim.h"'
                echo '#endif'
                cat src/util/sync/sync_spinlock.h
              } > "$tmp"
              mv "$tmp" src/util/sync/sync_spinlock.h
            else
              echo "sync_spinlock.h already includes shim (ok)"
            fi
          else
            echo "warn: src/util/sync/sync_spinlock.h not found (skipped)"
          fi

          # 3) DXVK 자체 소스 목록(서드파티 제외)
          find src include -type f \( -name '*.h' -o -name '*.hpp' -o -name '*.c' -o -name '*.cpp' -o -name '*.inl' \) \
            -not -path 'include/vulkan/*' -not -path 'include/spirv/*' > __filelist.txt

          # 4) x86 전용 인트린식 include 라인 주석화 (intrin.h 는 유지)
          mapfile -t KILL_HDRS < <(
            xargs -a __filelist.txt grep -RInE \
              '#\s*include\s*[<"]\s*((x86intrin|x86gprintrin|immintrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin))\.h\s*[>"]' 2>/dev/null \
            | cut -d: -f1 | sort -u
          )
          for f in "${KILL_HDRS[@]:-}"; do
            echo "Neutralizing x86 intrinsics includes in: $f"
            sed -i -E '/SAREK_ARM64EC neutralized/! s@(^\s*#\s*include\s*[<"]((x86intrin|x86gprintrin|immintrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin))\.h[>"])@/* SAREK_ARM64EC neutralized */ // \1@' "$f"
          done

          # 5) x86 감지 조건에 ARM64EC 제외
          mapfile -t COND_FILES < <(
            xargs -a __filelist.txt grep -RIl -E \
              'defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)' 2>/dev/null
          )
          for f in "${COND_FILES[@]:-}"; do
            echo "Patching arch guards in: $f"
            sed -i -E '/defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)/{
              /SAREK_ARM64EC|__arm64ec__|_M_ARM64EC/! s@defined\((__x86_64__|_M_X64|_M_AMD64|__i386__|_M_IX86)\)@defined(\1) \&\& !defined(SAREK_ARM64EC) \&\& !defined(__arm64ec__) \&\& !defined(_M_ARM64EC)@g
            }' "$f"
          done

          # 6) util_bit.h의 x86 asm(bsf/cmovz) 블록을 ARM64EC 전용 빌트인으로 포괄 치환
          python3 - <<'PY'
          import re, pathlib, sys
          p = pathlib.Path("src/util/util_bit.h")
          s = p.read_text(encoding="utf-8", errors="ignore")
          pat = re.compile(r'(?P<asm>(?:__asm__|asm)\s*(?:volatile\s*)?\(.*?\)\s*;)', re.IGNORECASE | re.DOTALL)
          def wrap(m):
              block = m.group('asm')
              low = block.lower()
              if 'bsf' in low or 'cmovz' in low:
                  return (
                      "#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)\n"
                      "      /* SAREK ARM64EC: replace x86 asm (bsf/cmovz) with builtin */\n"
                      "      res = (n ? __builtin_ctz((unsigned)n) : 32);\n"
                      "      tmp = 0;\n"
                      "#else\n" + block + "\n#endif\n"
                  )
              return block
          ns, n = pat.subn(wrap, s)
          if n == 0:
              print('error: could not find x86 asm block with bsf/cmovz to replace in util_bit.h', file=sys.stderr)
              sys.exit(1)
          p.write_text(ns, encoding="utf-8")
          print(f'patched util_bit.h: replaced {n} asm block(s)')
          PY

          # 7) 전처리 결과에서 x86 asm(bsf) / x86-only 헤더 존재 여부 검사 (남아있으면 실패)
          CXX=arm64ec-w64-mingw32-g++
          BASE="-std=c++17 -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 -D_FILE_OFFSET_BITS=64 -D_WIN32_WINNT=0x0A00 -DDXVK_WSI_WIN32 -I. -Isrc -Iinclude -fno-fast-math -ffp-contract=off"

          echo '#include "src/util/util_bit.h"' > __pp_probe.cpp
          $CXX -E -x c++ -P $BASE __pp_probe.cpp > __pp_probe.i

          if egrep -qi '(^|[^A-Za-z_])(asm|__asm__)\s*\([^;]*bsf' __pp_probe.i; then
            echo "::error:: Preprocessed output still contains x86 asm bsf under SAREK_ARM64EC"
            tail -n 200 __pp_probe.i || true
            exit 1
          fi
          if egrep -q '(immintrin|x86intrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin)\.h' __pp_probe.i; then
            echo "::error:: x86-only intrinsics header pulled in during preprocessing"
            exit 1
          fi
      
          # 8) 대표 TU 인클루드 트리 검사 — x86-only 헤더 유입 시 실패
          : > __inc_tree_all.log
          if $CXX -E -x c++ -H $BASE __pp_probe.cpp -o /dev/null &>> __inc_tree_all.log; then
            true
          fi
          find src -type f -name '*.cpp' | sort | head -n 20 > __probe_files.txt || true
          if [ -s __probe_files.txt ]; then
            mapfile -t more < __probe_files.txt
            for tu in "${more[@]}"; do
              $CXX -E -x c++ -H $BASE "$tu" -o /dev/null &>> __inc_tree_all.log || true
            done
          fi
          if grep -qE '/(immintrin|x86intrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin)\.h' __inc_tree_all.log; then
            echo "== Include tree tail ==" && tail -n 200 __inc_tree_all.log || true
            echo "::error:: x86-only intrinsics headers still included"
            exit 1
          fi

          echo "== Head of src/util/util_bit.h (after patch) =="
          head -n 60 src/util/util_bit.h || true

          # 9) D3D9 타입 호환 레이어 삽입(중복 방지)
          cat > include/sarek_d3d9_compat.h <<'HDR'
          #pragma once
          #if defined(__has_include)
          # if __has_include(<d3d9.h>)
          #  include <d3d9.h>
          # endif
          #endif
          #ifndef D3DDEVINFO_RESOURCEMANAGER
          #define D3DDEVINFO_RESOURCEMANAGER D3DDEVINFO_D3DRESOURCEMANAGER
          #endif
          #ifndef D3DDEVINFO_VERTEXSTATS
          #define D3DDEVINFO_VERTEXSTATS D3DDEVINFO_D3DVERTEXSTATS
          #endif
          HDR
          
          if [ -f src/d3d9/d3d9_include.h ]; then
            if ! grep -q 'sarek_d3d9_compat.h' src/d3d9/d3d9_include.h; then
              echo "Prepending D3D9 compat include to src/d3d9/d3d9_include.h"
              tmp=$(mktemp)
              { echo '#include "sarek_d3d9_compat.h"'; cat src/d3d9/d3d9_include.h; } > "$tmp"
              mv "$tmp" src/d3d9/d3d9_include.h
            else
              sed -i '1,16{s|#include <sarek_d3d9_compat.h>|#include "sarek_d3d9_compat.h"|}' src/d3d9/d3d9_include.h || true
            fi
          fi

      - name: Wipe build dir (idempotent & -e safe)
        working-directory: dxvk
        shell: bash
        run: |
          if [ -d build.w64 ]; then
            rm -rf build.w64
            echo "Removed build.w64"
          else
            echo "No build.w64 (ok)"
          fi
          if [ -d install ]; then
            rm -rf install
            echo "Removed install"
          else
            echo "No install (ok)"
          fi

      - name: "Preflight: meson.build presence"
        working-directory: dxvk
        run: |
          set -euo pipefail
          test -f meson.build || { echo "::error::meson.build not found in $PWD"; ls -la; exit 1; }

      - name: Configure (Meson)
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson setup build.w64 . --cross-file arm64ec.meson --buildtype release --prefix "$PWD/install"
          meson configure build.w64
          echo '== Meson build options (excerpt) =='
          meson introspect build.w64 --buildoptions | head -n 120 || true

      - name: Macro snapshot after configure (with injected defines)
        working-directory: dxvk
        run: |
          set -euo pipefail
          echo '== Predefined macros (+ our -D) =='
          arm64ec-w64-mingw32-g++ -dM -E -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 - < /dev/null | \
            egrep -E 'SAREK_ARM64EC|__CRT__NO_INLINE|__arm64ec__|_M_ARM64EC|__aarch64__|__x86_64__|_M_X64|_M_AMD64|__SSE__|__AVX__' || true

      - name: Build
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson compile -C build.w64 -v

      - name: Install into staging dir
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson install -C build.w64

      # === Trust gates (block artifacts if not meeting criteria) ===
      - name: Verify ARM64EC machine type
        working-directory: dxvk
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in install/bin/*.dll; do
            echo "== $f =="
            llvm-readobj -coff-headers "$f" | tee /dev/stderr | grep -E 'Machine:.*ARM64EC|0xA641'
          done

      - name: Enforce no x86 SIMD or x86 asm artifacts
        working-directory: dxvk
        run: |
          set -euo pipefail
          echo '#include "src/util/util_bit.h"' > __probe.cpp
          arm64ec-w64-mingw32-g++ -E -x c++ -P -DSAREK_ARM64EC=1 -I. -Isrc -Iinclude __probe.cpp > __probe.i
          if egrep -q '(immintrin|x86intrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin)\.h' __probe.i; then
            echo "::error:: x86-only intrinsics headers detected in preprocessed output"
            exit 1
          fi
          if egrep -qi '(^|[^A-Za-z_])(asm|__asm__)\s*\([^;]*bsf' __probe.i; then
            echo "::error:: x86 asm(bsf) artifacts remain in preprocessed output"
            exit 1
          fi

      - name: Ensure only supported intrinsics are referenced
        working-directory: dxvk
        run: |
          set -euo pipefail
          UNSUP=$(grep -RInE '_mm_[A-Za-z0-9_]+' src include | \
            grep -Ev '_mm_(pause|loadu_ps|storeu_ps|cmpeq_ps|and_ps|setzero_si128|set1_epi8|loadu?_si128|storeu?_si128|cmpeq_epi8|and_si128|or_si128|xor_si128|movemask_epi8)\b' || true)
          if [ -n "$UNSUP" ]; then
            echo "$UNSUP"
            echo "::error:: unsupported _mm_* intrinsic found (extend shim or avoid)"
            exit 1
          fi

      - name: Upload DLL artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-dlls
          path: |
            dxvk/install/bin/*.dll
            dxvk/install/bin/*.pdb
          if-no-files-found: error

      - name: Upload build logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-logs
          path: |
            dxvk/build.w64/meson-logs/**
            dxvk/build.w64/meson-info/**
            dxvk/meson-logs/**
            dxvk/arm64ec.meson
            dxvk/__inc_tree_all.log
            dxvk/__inc_dep_err.log
            dxvk/__inc_deps_all.txt
            dxvk/__pp_probe.i
            dxvk/__probe.i
          if-no-files-found: warn
