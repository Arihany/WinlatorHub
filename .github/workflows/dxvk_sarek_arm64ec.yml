name: Build DXVK-Sarek (arm64ec + i686) — fast DLL test

on:
  workflow_dispatch:

permissions:
  contents: read

defaults:
  run:
    shell: bash -Eeuo pipefail {0}

jobs:
  build:
    name: Build DLLs (arm64ec + i686)
    runs-on: ubuntu-24.04
    env:
      # toolchain & output dirs
      LLVM_MINGW_DIR: ${{ github.workspace }}/.toolchains/llvm-mingw
      OUT_DIR:        ${{ github.workspace }}/out
      SAREK_REPO:     pythonlover02/DXVK-Sarek
    steps:
      - name: Install host deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            curl xz-utils jq ca-certificates git meson ninja-build \
            python3 pkg-config glslang-tools llvm binutils file

      - name: Fetch bylaws llvm-mingw (Ubuntu 20.04 x86_64)
        env:
          API: https://api.github.com/repos/bylaws/llvm-mingw/releases/latest
        run: |
          mkdir -p "$LLVM_MINGW_DIR"
          json="$(curl -fsSL -H 'Accept: application/vnd.github+json' "$API")"

          # 이 리포는 22.04 자산이 없어요 → 20.04만 검색
          url="$(
            echo "$json" | jq -r '
              .assets[] |
              select(.name|test("ucrt-ubuntu-20\\.04-x86_64\\.tar\\.xz$")) |
              .browser_download_url' | head -n1
          )"
          [ -n "$url" ] || { echo "::error::llvm-mingw asset not found (ubuntu-20.04 x86_64)"; exit 1; }

          echo "Chosen: $url"
          curl -fL "$url" -o /tmp/llvm-mingw.tar.xz
          tar -C "$LLVM_MINGW_DIR" --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "$LLVM_MINGW_DIR/bin" >> "$GITHUB_PATH"

      - name: Toolchain sanity (arm64ec helper lib check)
        id: tc
        run: |
          set -x
          which clang
          which i686-w64-mingw32-clang
          which llvm-rc
          which llvm-ar
          which llvm-nm
          which llvm-readobj

          # ARM64EC helper 라이브러리 존재 확인 + 경로 추출
          ARM_WIN_DIR="$(echo "$LLVM_MINGW_DIR"/lib/clang/*/lib/windows)"
          HELPER="$ARM_WIN_DIR/libclang_rt.builtins-arm64ec.a"
          [ -f "$HELPER" ] || { echo "::error::missing $HELPER"; exit 1; }

          echo "ARM_WIN_DIR=$ARM_WIN_DIR" >> "$GITHUB_OUTPUT"
          echo "ARM64EC_HELPER_LIB=$HELPER" >> "$GITHUB_OUTPUT"

          echo "== nm: expect __icall_helper_arm64ec symbol =="
          if ! llvm-nm -g "$HELPER" | grep -q '__icall_helper_arm64ec'; then
            echo "::warning::__icall_helper_arm64ec not visible via nm (will still force include with --whole-archive)"
          fi

      - name: Clone DXVK-Sarek (main + submodules)
        run: |
          git clone --recurse-submodules https://github.com/${SAREK_REPO}.git src
          cd src
          git fetch origin main --force
          git checkout -f origin/main
          git submodule update --init --recursive --checkout

      - name: Write Meson cross file (ARM64EC)
        run: |
          cat > cross.arm64ec.ini <<'INI'
          [binaries]
          c = ['clang',   '--target=arm64ec-w64-mingw32']
          cpp = ['clang++','--target=arm64ec-w64-mingw32']
          ar = 'llvm-ar'
          strip = 'llvm-strip'
          windres = ['llvm-rc']

          [host_machine]
          system = 'windows'
          cpu_family = 'arm64'
          cpu = 'arm64'
          endian = 'little'

          [built-in options]
          c_args = ['-D_WIN32_WINNT=0x0A00','-DWINVER=0x0A00']
          cpp_args = ['-D_WIN32_WINNT=0x0A00','-DWINVER=0x0A00']
          # 핵심: ARM64EC helper 정적 라이브러리를 강제로 통째로 포함해 심볼 미해결 방지
          c_link_args = []
          cpp_link_args = []
          INI

          # 동적으로 helper 경로 추가 (whole-archive)
          sed -i "s|^c_link_args = \[\]|c_link_args = ['-fuse-ld=lld','-Wl,--whole-archive,${{ steps.tc.outputs.ARM64EC_HELPER_LIB }},--no-whole-archive','-L${{ steps.tc.outputs.ARM_WIN_DIR }}']|" cross.arm64ec.ini
          sed -i "s|^cpp_link_args = \[\]|cpp_link_args = ['-fuse-ld=lld','-Wl,--whole-archive,${{ steps.tc.outputs.ARM64EC_HELPER_LIB }},--no-whole-archive','-L${{ steps.tc.outputs.ARM_WIN_DIR }}']|" cross.arm64ec.ini

          echo "### cross.arm64ec.ini"
          cat cross.arm64ec.ini

      - name: Write Meson cross file (i686)
        run: |
          cat > cross.i686.ini <<'INI'
          [binaries]
          c = 'i686-w64-mingw32-clang'
          cpp = 'i686-w64-mingw32-clang++'
          ar = 'llvm-ar'
          strip = 'llvm-strip'
          windres = ['llvm-rc']

          [host_machine]
          system = 'windows'
          cpu_family = 'x86'
          cpu = 'i686'
          endian = 'little'

          [built-in options]
          c_args = ['-D_WIN32_WINNT=0x0601','-DWINVER=0x0601']
          cpp_args = ['-D_WIN32_WINNT=0x0601','-DWINVER=0x0601']
          c_link_args = ['-fuse-ld=lld']
          cpp_link_args = ['-fuse-ld=lld']
          INI
          echo "### cross.i686.ini"
          cat cross.i686.ini

      - name: Build (ARM64EC)
        working-directory: src
        run: |
          PREFIX="${{ env.OUT_DIR }}/arm64ec"
          rm -rf build.arm64ec "$PREFIX"
          meson setup build.arm64ec \
            --cross-file ../cross.arm64ec.ini \
            --buildtype release \
            --prefix "$PREFIX" \
            -Dbuild_id=false -Dstrip=true
          ninja -C build.arm64ec -j"$(nproc)"
          meson install --no-rebuild -C build.arm64ec

          echo "== file headers =="
          find "$PREFIX/bin" -name '*.dll' -print0 | xargs -0 -I{} sh -c 'echo "# {}"; llvm-readobj -file-headers "{}" | sed -n "1,40p"'

      - name: Build (i686)
        working-directory: src
        run: |
          PREFIX="${{ env.OUT_DIR }}/i686"
          rm -rf build.i686 "$PREFIX"
          meson setup build.i686 \
            --cross-file ../cross.i686.ini \
            --buildtype release \
            --prefix "$PREFIX" \
            -Dbuild_id=false -Dstrip=true
          ninja -C build.i686 -j"$(nproc)"
          meson install --no-rebuild -C build.i686

      - name: Prepare artifacts
        run: |
          mkdir -p "$OUT_DIR/zips"
          (cd "$OUT_DIR/arm64ec/bin" && ls -1 *.dll || true)
          (cd "$OUT_DIR/i686/bin"    && ls -1 *.dll || true)

          tar -C "$OUT_DIR/arm64ec/bin" -czf "$OUT_DIR/zips/dxvk-sarek-arm64ec-dlls.tgz" .
          tar -C "$OUT_DIR/i686/bin"    -czf "$OUT_DIR/zips/dxvk-sarek-i686-dlls.tgz" .

      - name: Upload ARM64EC DLLs
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-dlls
          path: ${{ env.OUT_DIR }}/zips/dxvk-sarek-arm64ec-dlls.tgz
          if-no-files-found: error
          retention-days: 7

      - name: Upload i686 DLLs
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-i686-dlls
          path: ${{ env.OUT_DIR }}/zips/dxvk-sarek-i686-dlls.tgz
          if-no-files-found: error
          retention-days: 7
