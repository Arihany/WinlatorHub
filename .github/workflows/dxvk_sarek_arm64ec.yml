name: Build DXVK-Sarek arm64ec

on:
  workflow_dispatch:              # Manual trigger (any branch)
  schedule:
    - cron: "0 18 * * *"         # Daily (UTC)

permissions:
  contents: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guard:
    name: Fast guard (new Sarek tag?)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      build: ${{ steps.decide.outputs.build }}
    env:
      GH_TOKEN: ${{ github.token }}
      REPO: ${{ github.repository }}
      SAREK_REPO: pythonlover02/DXVK-Sarek
      RELEASE_TAG: DXVK-SAREK-ARM64EC
    steps:
      - name: Install jq, curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends jq curl

      - name: Collect already-published versions (DXVK-SAREK-ARM64EC)
        id: have
        run: |
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")
          HTTP="$(curl -s -o /tmp/rel.json -w '%{http_code}' "${auth[@]}" "${ver[@]}" \
                  "$API/repos/${REPO}/releases/tags/${RELEASE_TAG}" || true)"
          if [ "$HTTP" = "200" ]; then
            jq -r '.assets[].name' /tmp/rel.json \
              | sed -n -E 's/^dxvk-sarek-arm64ec-([0-9]+\.[0-9]+(\.[0-9]+)?)\.wcp$/\1/p' \
              | sort -V > /tmp/exist.txt
          else
            : > /tmp/exist.txt
          fi
          echo "Existing:"; cat /tmp/exist.txt || true

      - name: Detect any missing tag (API-only; min v1.10.8)
        id: detect
        env:
          MIN_VER: "1.10.8"
        run: |
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")

          curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${SAREK_REPO}/tags?per_page=100" \
            | jq -r '.[].name' \
            | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' \
            | sort -V > /tmp/tags.txt

          awk -v MIN="${MIN_VER}" '
            function cmp(a,b,  i,A,B){split(a,A,".");split(b,B,".");
              for(i=1;i<=3;i++){if((A[i]+0)<(B[i]+0))return -1;if((A[i]+0)>(B[i]+0))return 1}return 0}
            { base=substr($0,2); if (cmp(base,MIN)>=0) print base }
          ' /tmp/tags.txt > /tmp/candidates.txt

          echo "Candidates (>= ${MIN_VER}):"; cat /tmp/candidates.txt || true

          echo -n "no" > /tmp/missing.flag
          while read -r base; do
            [ -n "$base" ] || continue
            if ! grep -Fxq "$base" /tmp/exist.txt; then
              echo "MISSING: $base"
              echo -n "yes" > /tmp/missing.flag
              break
            fi
          done < /tmp/candidates.txt

          [ "$(cat /tmp/missing.flag 2>/dev/null || echo no)" = "yes" ] && echo "missing=true"  >> "$GITHUB_OUTPUT" || echo "missing=false" >> "$GITHUB_OUTPUT"

      - name: Decide build
        id: decide
        run: |
          if [ "${{ steps.detect.outputs.missing }}" = "true" ]; then
            echo "build=true"  >> "$GITHUB_OUTPUT"
          else
            echo "build=false" >> "$GITHUB_OUTPUT"
          fi

  build-and-release:
    name: Build & release DXVK-Sarek (ARM64EC + 32-bit)
    runs-on: ubuntu-24.04
    needs: guard
    if: needs.guard.outputs.build == 'true'
    env:
      SAREK_REPO: pythonlover02/DXVK-Sarek
      PREFIX_X64: ${{ github.workspace }}/dist-arm64ec   # system32 (ARM64EC)
      PREFIX_X86: ${{ github.workspace }}/dist-x86       # syswow64 (i686)
      TOOLCHAIN_DIR: /opt/llvm-mingw                     # mstorsjo/llvm-mingw
      RELEASE_TAG: DXVK-SAREK-ARM64EC
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Install host tooling (lean)
        run: |
          sudo apt-get -yq update
          sudo apt-get -yq install --no-install-recommends \
            curl xz-utils jq ca-certificates \
            git meson ninja-build glslang-tools pkg-config \
            build-essential python3 zstd file rsync gh

      - name: Ensure glslang (--vn) available
        run: |
          cat > /tmp/min.comp <<'GLSL'
          #version 450
          void main() {}
          GLSL
          try() { command -v "$1" >/dev/null 2>&1 || return 1; "$1" --quiet --target-env vulkan1.1 --vn testvar -o /tmp/min.h /tmp/min.comp; }
          if try glslang; then :
          elif try glslangValidator; then
            BIN="$HOME/.local/bin"; mkdir -p "$BIN"
            ln -sf "$(command -v glslangValidator)" "$BIN/glslang"
            echo "$BIN" >> "$GITHUB_PATH"
          else
            echo "::error::No glslang/glslangValidator with working --vn"; exit 1
          fi

      - name: Download llvm-mingw (ucrt, ubuntu x86_64) from mstorsjo
        run: |
          set -Eeuo pipefail
          json=$(curl -fsSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
                 https://api.github.com/repos/mstorsjo/llvm-mingw/releases/latest)
          url=$(echo "$json" | jq -r '.assets[] | select(.name|test("ucrt-ubuntu-.*-x86_64\\.tar\\.xz$")) .browser_download_url' | head -n1)
          [[ -n "$url" ]] || { echo "::error::llvm-mingw asset not found"; exit 1; }
          sudo mkdir -p "$TOOLCHAIN_DIR"
          curl -fL -H "Authorization: Bearer $GH_TOKEN" "$url" -o /tmp/llvm-mingw.tar.xz
          sudo tar -C "$TOOLCHAIN_DIR" --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "$TOOLCHAIN_DIR/bin" >> "$GITHUB_PATH"
          export PATH="$TOOLCHAIN_DIR/bin:$PATH"

      - name: Write ARM64EC shim (pre-include)
        run: |
          cat > "${GITHUB_WORKSPACE}/arm64ec_shim.h" <<'EOF'
          #pragma once
          /* Avoid winbase.h inline conflicts and force ARM64EC tags */
          #ifndef NOWINBASEINTERLOCK
          #define NOWINBASEINTERLOCK 1
          #endif
          #ifndef __CRT__NO_INLINE
          #define __CRT__NO_INLINE 1
          #endif
          #ifndef _M_ARM64EC
          #define _M_ARM64EC 1
          #endif
          #ifndef __ARM64EC__
          #define __ARM64EC__ 1
          #endif
          #ifndef __aarch64__
          #define __aarch64__ 1
          #endif
          /* Ask intrin-impl.h not to use flag outputs */
          #ifdef __GCC_ASM_FLAG_OUTPUTS__
          #undef __GCC_ASM_FLAG_OUTPUTS__
          #endif
          EOF

      - name: Inject ARM64EC-safe bit-test intrinsics (override intrin-impl.h)
        run: |
          set -Eeuo pipefail
          HDR="$TOOLCHAIN_DIR/arm64ec-w64-mingw32/include/psdk_inc/intrin-impl.h"
          [ -f "$HDR" ] || { echo "::error::intrin-impl.h not found at $HDR"; exit 1; }
          sudo cp -f "$HDR" "${HDR}.bak"
          tmp="$(mktemp)"
          cat > "$tmp" <<'OVR'
          /* ---- ARM64EC override (CI) ---- */
          #if defined(_M_ARM64EC) || defined(__ARM64EC__)
          #ifndef __MINGW_ARM64EC_BTEST_OVERRIDE
          #define __MINGW_ARM64EC_BTEST_OVERRIDE 1
          #undef __GCC_ASM_FLAG_OUTPUTS__
          #undef __buildbittesti
          #undef __buildbittesti64
          #define __ARM64EC_INLINE static inline __attribute__((__always_inline__))

          /* 32-bit bit-test intrinsics (atomic-based) */
          #define __IMPL32__interlockedbittestandset \
          __ARM64EC_INLINE unsigned char _interlockedbittestandset(long volatile* Base, long Offset){ \
            unsigned long idx=((unsigned long)Offset>>5); unsigned long m=1u<<(Offset&31); \
            volatile unsigned long* p=(volatile unsigned long*)Base+idx; \
            unsigned long old=__atomic_fetch_or((unsigned long*)p,m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL32__interlockedbittestandreset \
          __ARM64EC_INLINE unsigned char _interlockedbittestandreset(long volatile* Base, long Offset){ \
            unsigned long idx=((unsigned long)Offset>>5); unsigned long m=1u<<(Offset&31); \
            volatile unsigned long* p=(volatile unsigned long*)Base+idx; \
            unsigned long old=__atomic_fetch_and((unsigned long*)p,~m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL32__interlockedbittestandcomplement \
          __ARM64EC_INLINE unsigned char _interlockedbittestandcomplement(long volatile* Base, long Offset){ \
            unsigned long idx=((unsigned long)Offset>>5); unsigned long m=1u<<(Offset&31); \
            volatile unsigned long* p=(volatile unsigned long*)Base+idx; \
            unsigned long old=__atomic_fetch_xor((unsigned long*)p,m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL32_InterlockedBitTestAndSet \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndSet(long volatile* Base, long Offset){ \
            return _interlockedbittestandset(Base,Offset); }

          #define __IMPL32_InterlockedBitTestAndReset \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndReset(long volatile* Base, long Offset){ \
            return _interlockedbittestandreset(Base,Offset); }

          #define __IMPL32_InterlockedBitTestAndComplement \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndComplement(long volatile* Base, long Offset){ \
            return _interlockedbittestandcomplement(Base,Offset); }

          /* 64-bit bit-test intrinsics (atomic-based) */
          #define __IMPL64__interlockedbittestandset64 \
          __ARM64EC_INLINE unsigned char _interlockedbittestandset64(long long volatile* Base, long long Offset){ \
            unsigned long long idx=((unsigned long long)Offset>>6); unsigned long long m=1ull<<(Offset&63); \
            volatile unsigned long long* p=(volatile unsigned long long*)Base+idx; \
            unsigned long long old=__atomic_fetch_or((unsigned long long*)p,m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL64__interlockedbittestandreset64 \
          __ARM64EC_INLINE unsigned char _interlockedbittestandreset64(long long volatile* Base, long long Offset){ \
            unsigned long long idx=((unsigned long long)Offset>>6); unsigned long long m=1ull<<(Offset&63); \
            volatile unsigned long long* p=(volatile unsigned long long*)Base+idx; \
            unsigned long long old=__atomic_fetch_and((unsigned long long*)p,~m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL64__interlockedbittestandcomplement64 \
          __ARM64EC_INLINE unsigned char _interlockedbittestandcomplement64(long long volatile* Base, long long Offset){ \
            unsigned long long idx=((unsigned long long)Offset>>6); unsigned long long m=1ull<<(Offset&63); \
            volatile unsigned long long* p=(volatile unsigned long long*)Base+idx; \
            unsigned long long old=__atomic_fetch_xor((unsigned long long*)p,m,__ATOMIC_SEQ_CST); \
            return (old&m)?1:0; }

          #define __IMPL64_InterlockedBitTestAndSet64 \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndSet64(long long volatile* Base, long long Offset){ \
            return _interlockedbittestandset64(Base,Offset); }

          #define __IMPL64_InterlockedBitTestAndReset64 \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndReset64(long long volatile* Base, long long Offset){ \
            return _interlockedbittestandreset64(Base,Offset); }

          #define __IMPL64_InterlockedBitTestAndComplement64 \
          __ARM64EC_INLINE unsigned char InterlockedBitTestAndComplement64(long long volatile* Base, long long Offset){ \
            return _interlockedbittestandcomplement64(Base,Offset); }

          /* map builders to our implementations */
          #define __buildbittesti(NAME, TYP, OP, EXTRA)   __IMPL32_##NAME
          #define __buildbittesti64(NAME, TYP, OP, EXTRA) __IMPL64_##NAME
          #endif
          #endif
          /* ---- end ARM64EC override ---- */
          OVR
          cat "${HDR}.bak" >> "$tmp"
          sudo mv "$tmp" "$HDR"
          echo "[ok] injected ARM64EC override into $(basename "$HDR")"

      - name: Remap intrin builders AFTER their original #define (force replace)
        run: |
          set -Eeuo pipefail
          HDR="$TOOLCHAIN_DIR/arm64ec-w64-mingw32/include/psdk_inc/intrin-impl.h"
          [ -f "$HDR" ] || { echo "::error::intrin-impl.h not found at $HDR"; exit 1; }
          sudo cp -f "$HDR" "${HDR}.pre-map.bak"
      
          # 멀티라인 매크로 본문을 통째로 스킵하고, ARM64EC일 때 우리 구현으로 치환
          tmp="$(mktemp)"
          sudo awk '
            function emit32() {
              print "#if defined(_M_ARM64EC) || defined(__ARM64EC__)"
              print "#undef __buildbittesti"
              print "#define __buildbittesti(NAME, TYP, OP, EXTRA) __IMPL32_##NAME"
              print "#endif"
            }
            function emit64() {
              print "#if defined(_M_ARM64EC) || defined(__ARM64EC__)"
              print "#undef __buildbittesti64"
              print "#define __buildbittesti64(NAME, TYP, OP, EXTRA) __IMPL64_##NAME"
              print "#endif"
            }
      
            BEGIN { skip=0; mode=0 }  # mode: 0=일반, 32=__buildbittesti 본문 스킵, 64=__buildbittesti64 본문 스킵
            {
              if (mode==32) {
                # 매크로 본문은 백슬래시가 끝날 때까지 스킵
                if ($0 ~ /\\$/) next; else { mode=0; next }
              } else if (mode==64) {
                if ($0 ~ /\\$/) next; else { mode=0; next }
              }
      
              # 원본 매크로 정의 라인을 만나면 그 줄도 버리고, 대신 우리 치환 블록 출력
              if ($0 ~ /^#[[:space:]]*define[[:space:]]+__buildbittesti\(/) { emit32(); mode=32; next }
              if ($0 ~ /^#[[:space:]]*define[[:space:]]+__buildbittesti64\(/) { emit64(); mode=64; next }
      
              print
            }
          ' "${HDR}.pre-map.bak" | sudo tee "$tmp" >/dev/null
      
          # 플래그 제약도 안전하게: __FLAGCONSTRAINT가 "=@ccc"로 가지 않게 고정
          # (혹여 원본이 다시 정의했다 쳐도, 아래 sed로 마지막에 "=r"로 덮어쓴다)
          sudo mv "$tmp" "$HDR"
          sudo sed -i 's/^#define[[:space:]]\+__FLAGCONSTRAINT.*/#define __FLAGCONSTRAINT "=r"/' "$HDR"
      
          echo "---- sanity: should show our remap (IMPL32/64) and no inline asm use ----"
          grep -n "^#define[[:space:]]\+__buildbittesti" "$HDR" | head -n 2 || true
          grep -n "^#define[[:space:]]\+__buildbittesti64" "$HDR" | head -n 2 || true
     
      - name: Create Meson cross files (DXVK-style; arm64ec + i686)
        run: |
          set -Eeuo pipefail
          pick() { command -v "$1" >/dev/null 2>&1 && echo "$1" || echo "$2"; }

          # --- arm64ec (prefer GCC wrappers; robust fallbacks) ---
          A_AR=$(pick arm64ec-w64-mingw32-ar arm64ec-w64-mingw32-ar)
          A_CC=$(pick arm64ec-w64-mingw32-gcc arm64ec-w64-mingw32-clang)
          A_CXX=$(pick arm64ec-w64-mingw32-g++ arm64ec-w64-mingw32-clang++)
          A_RC=$(pick arm64ec-w64-mingw32-windres llvm-rc)
          A_STRIP=$(pick llvm-strip arm64ec-w64-mingw32-strip)
          A_WIDL=$(pick arm64ec-w64-mingw32-widl widl)
          A_PKG=$(pick aarch64-linux-gnu-pkg-config pkg-config)

          cat > "${{ github.workspace }}/arm64ec.cross" <<EOF
          [binaries]
          ar = '${A_AR}'
          c = '${A_CC}'
          cpp = '${A_CXX}'
          windres = '${A_RC}'
          strip = '${A_STRIP}'
          widl = '${A_WIDL}'
          pkgconfig = '${A_PKG}'
          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
          [properties]
          needs_exe_wrapper = true
          [built-in options]
          c_args  = ['-Wno-nontrivial-memcall','-include','${GITHUB_WORKSPACE}/arm64ec_shim.h','-DNOWINBASEINTERLOCK','-D__CRT__NO_INLINE','-D_M_ARM64EC=1','-D__ARM64EC__=1','-D__aarch64__=1']
          cpp_args= ['-Wno-nontrivial-memcall','-include','${GITHUB_WORKSPACE}/arm64ec_shim.h','-DNOWINBASEINTERLOCK','-D__CRT__NO_INLINE','-D_M_ARM64EC=1','-D__ARM64EC__=1','-D__aarch64__=1']
          EOF

          # --- i686 (32-bit) ---
          I_AR=$(pick i686-w64-mingw32-ar i686-w64-mingw32-ar)
          I_CC=$(pick i686-w64-mingw32-gcc i686-w64-mingw32-clang)
          I_CXX=$(pick i686-w64-mingw32-g++ i686-w64-mingw32-clang++)
          I_RC=$(pick i686-w64-mingw32-windres llvm-rc)
          I_STRIP=$(pick llvm-strip i686-w64-mingw32-strip)
          I_PKG=$(pick i686-w64-mingw32-pkg-config pkg-config)

          cat > "${{ github.workspace }}/i686.cross" <<EOF
          [binaries]
          ar = '${I_AR}'
          c = '${I_CC}'
          cpp = '${I_CXX}'
          windres = '${I_RC}'
          strip = '${I_STRIP}'
          pkgconfig = '${I_PKG}'
          [host_machine]
          system = 'windows'
          cpu_family = 'x86'
          cpu = 'i686'
          endian = 'little'
          [properties]
          needs_exe_wrapper = true
          [built-in options]
          c_args = ['-Wno-nontrivial-memcall']
          cpp_args = ['-Wno-nontrivial-memcall']
          EOF

      - name: Clone DXVK-Sarek (tags + submodules)
        run: |
          git clone --recurse-submodules https://github.com/${SAREK_REPO}.git src
          cd src
          git fetch --tags --force
          git fetch origin main --force

      - name: Resolve Sarek tags (>= v1.10.8, Async 제외) & compute NEW
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          cd src
          git tag --merged origin/main -l 'v*' \
            | { grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' || true; } \
            | sort -V \
            | awk '
                function cmp(a,b,  i,A,B){split(a,A,".");split(b,B,".");
                  for(i=1;i<=3;i++){if((A[i]+0)<(B[i]+0))return -1;if((A[i]+0)>(B[i]+0))return 1}return 0}
                {ver=substr($0,2); if (cmp(ver,"1.10.8")>=0) print $0}
              ' > "${GITHUB_WORKSPACE}/versions.txt"

          : > "${GITHUB_WORKSPACE}/to_build.txt"

          EXIST="/tmp/exist.txt"; : > "$EXIST"
          if curl -sf -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
               "https://api.github.com/repos/${REPO}/releases/tags/${RELEASE_TAG}" -o /tmp/rel.json; then
            jq -r '.assets[].name' /tmp/rel.json \
              | sed -n -E 's/^dxvk-sarek-arm64ec-([0-9]+\.[0-9]+(\.[0-9]+)?)\.wcp$/\1/p' \
              | sort -V > "$EXIST" || true
          fi

          while IFS= read -r tag; do
            [ -n "$tag" ] || continue
            base="${tag#v}"
            if ! grep -Fxq "$base" "$EXIST"; then
              echo "$tag $base" >> "${GITHUB_WORKSPACE}/to_build.txt"
            fi
          done < "${GITHUB_WORKSPACE}/versions.txt"

          echo "Candidates:";       cat "${GITHUB_WORKSPACE}/versions.txt" || true
          echo "Already uploaded:"; cat "$EXIST" || true
          echo "To build:";         cat "${GITHUB_WORKSPACE}/to_build.txt" || true

      - name: Build NEW versions only (DXVK-Sarek → WCP)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -Eeuo pipefail
          OUT="${GITHUB_WORKSPACE}/out"; mkdir -p "$OUT"
          cd "${GITHUB_WORKSPACE}/src"

          LIST="${GITHUB_WORKSPACE}/to_build.txt"
          if [[ ! -f "$LIST" || ! -s "$LIST" ]]; then
            echo "No new versions to build."; exit 0; fi

          while read -r tag base; do
            echo "::group::Build ${tag} (dxvk-sarek ARM64EC + 32-bit)"
            git checkout -f "$tag"
            git submodule update --init --recursive --checkout

            # HUD retag (keep upstream tag name, clean tree)
            git config user.name  "ci"
            git config user.email "ci@local"
            git config --global --add safe.directory "$(pwd)"
            git add -A
            git commit -m "local compat patches for ${base}" || true
            git tag -d "$tag" || true
            git tag -a "$tag" -m "clean retag for HUD version"
            git reset --hard HEAD
            git clean -xdf

            rm -rf "${GITHUB_WORKSPACE}/build.ec" "${GITHUB_WORKSPACE}/build.w32" \
                   "${PREFIX_X64}" "${PREFIX_X86}" "${GITHUB_WORKSPACE}/DXVK_WCP"

            # ARM64EC (system32)
            meson setup "${GITHUB_WORKSPACE}/build.ec" \
              --cross-file "${GITHUB_WORKSPACE}/arm64ec.cross" \
              --buildtype release \
              --prefix "${PREFIX_X64}" \
              -Dbuild_id=false -Dstrip=true
            ninja -C "${GITHUB_WORKSPACE}/build.ec" -j"$(nproc)"
            meson install --no-rebuild -C "${GITHUB_WORKSPACE}/build.ec"

            # 32-bit (syswow64)
            meson setup "${GITHUB_WORKSPACE}/build.w32" \
              --cross-file "${GITHUB_WORKSPACE}/i686.cross" \
              --buildtype release \
              --prefix "${PREFIX_X86}" \
              -Dbuild_id=false -Dstrip=true
            ninja -C "${GITHUB_WORKSPACE}/build.w32" -j"$(nproc)"
            meson install --no-rebuild -C "${GITHUB_WORKSPACE}/build.w32"

            # Layout → WCP
            mkdir -p "${GITHUB_WORKSPACE}/DXVK_WCP/system32" "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64"
            cp -v "${PREFIX_X64}/bin/"*.dll  "${GITHUB_WORKSPACE}/DXVK_WCP/system32/" || true
            cp -v "${PREFIX_X86}/bin/"*.dll  "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64/" || true

            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find system32 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | sort) > /tmp/x64.txt || true
            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find syswow64 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | sort) > /tmp/x86.txt || true
            if [[ ! -s /tmp/x64.txt && ! -s /tmp/x86.txt ]]; then
              echo "::error::No DLLs discovered for ${base}"; exit 1; fi

            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x64.txt  > /tmp/x64.json
            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x86.txt  > /tmp/x86.json

            jq -n \
              --arg VN "sarek-${base}" \
              --argjson VC 0 \
              --arg DESC "DXVK-Sarek arm64ec build by Ari" \
              --arg SYS '${system32}/' \
              --arg WOW '${syswow64}/' \
              --slurpfile x64 /tmp/x64.json \
              --slurpfile x86 /tmp/x86.json \
              '
              ($x64[0] // []) as $A |
              ($x86[0] // []) as $B |
              {
                type: "DXVK",
                versionName: $VN,
                versionCode: $VC,
                description: $DESC,
                files: [
                  ($A[]? | {source: ("system32/"+.), target: ($SYS + .)}),
                  ($B[]? | {source: ("syswow64/"+.), target: ($WOW + .)})
                ]
              }' > "${GITHUB_WORKSPACE}/DXVK_WCP/profile.json"

            mkdir -p "${GITHUB_WORKSPACE}/out"
            wcp="dxvk-sarek-arm64ec-${base}.wcp"
            tar -C "${GITHUB_WORKSPACE}/DXVK_WCP" --zstd \
                --format=gnu --owner=0 --group=0 --numeric-owner \
                -cf "${GITHUB_WORKSPACE}/out/${wcp}" profile.json system32 syswow64
            echo "::endgroup::"
          done < "$LIST"

      - name: Build release notes (with Current)
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          printf '🤖 Automated DXVK-Sarek arm64ec builds (1.10.8+).\n\n' > "$NOTES"
          if compgen -G "${GITHUB_WORKSPACE}/out/dxvk-sarek-arm64ec-*.wcp" > /dev/null; then
            latest="$(ls -1 "${GITHUB_WORKSPACE}/out"/dxvk-sarek-arm64ec-*.wcp | sed 's#.*/##' | LC_ALL=C sort -V | tail -n1)"
            cur="${latest#dxvk-sarek-arm64ec-}"; cur="${cur%.wcp}"
            echo "Current: ${cur}" >> "$NOTES"
          fi
          cat "$NOTES"

      - name: Create/Update GitHub Release (DXVK-SAREK-ARM64EC) + upload WCPs
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          RELEASE_TAG="${RELEASE_TAG}"

          if ! gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh release create "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          else
            gh release edit   "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          fi

          if compgen -G "${GITHUB_WORKSPACE}/out/*.wcp" > /dev/null; then
            gh release upload "${RELEASE_TAG}" "${GITHUB_WORKSPACE}/out/"*.wcp --repo "${REPO}" --clobber
          else
            echo "No new WCP files to upload."
          fi

      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: meson-logs
          path: |
            ${{ github.workspace }}/build.ec/meson-logs/**
            ${{ github.workspace }}/build.w32/meson-logs/**
