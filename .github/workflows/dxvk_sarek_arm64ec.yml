name: Build DXVK-Sarek (arm64ec + i686) — quick DLL test

on:
  workflow_dispatch:

permissions:
  contents: read

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

jobs:
  build:
    runs-on: ubuntu-24.04
    timeout-minutes: 45
    env:
      SAREK_REPO: pythonlover02/DXVK-Sarek
      LLVM_MINGW_DIR: ${{ github.workspace }}/.toolchains/llvm-mingw
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Install build deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            curl xz-utils zstd jq ca-certificates \
            git meson ninja-build glslang-tools pkg-config \
            python3 build-essential file

          # glslangValidator만 있을 때 --vn 대체용 래퍼
          if command -v glslangValidator >/dev/null && ! command -v glslang >/dev/null; then
            BIN="$HOME/.local/bin"; mkdir -p "$BIN"
            ln -sf "$(command -v glslangValidator)" "$BIN/glslang"
            echo "$BIN" >> "$GITHUB_PATH"
          fi

      - name: Download bylaws llvm-mingw (latest by release title=date; 20.04 only)
        run: |
          set -Eeuo pipefail
          mkdir -p "$LLVM_MINGW_DIR"

          API="https://api.github.com/repos/bylaws/llvm-mingw/releases/latest"
          json="$(curl -fsSL -H 'Accept: application/vnd.github+json' -H "Authorization: Bearer $GH_TOKEN" "$API")"

          DATE="$(echo "$json" | jq -r '.name' | sed 's/[^0-9]//g')"   # ex) 20250305
          [ -n "$DATE" ] || { echo "::error::Failed to parse release date (title)"; exit 1; }

          cand="llvm-mingw-${DATE}-ucrt-ubuntu-20.04-x86_64.tar.xz"
          url="$(echo "$json" | jq -r --arg N "$cand" '.assets[] | select(.name==$N) .browser_download_url')"

          # 같은 날짜에서 ubuntu x86_64 tar.* 임의 선택(해당 리포는 20.04만 배포)
          if [ -z "$url" ] || [ "$url" = "null" ]; then
            url="$(echo "$json" | jq -r --arg D "$DATE" '
              .assets[] |
              select((.name|test($D)) and (.name|test("ubuntu.*x86_64\\.(tar\\.(xz|zst|gz)|t(z|x|g)z)$";"i"))) |
              .browser_download_url' | head -n1)"
          fi

          if [ -z "$url" ] || [ "$url" = "null" ]; then
            echo "::group::Available assets in latest"
            echo "$json" | jq -r '.assets[].name'
            echo "::endgroup::"
            echo "::error::No matching llvm-mingw 20.04 asset for date $DATE"
            exit 1
          fi

          echo "Chosen: $url"
          f=/tmp/llvm-mingw.tar.any
          curl -fL "$url" -o "$f"

          case "$url" in
            *.tar.xz|*.txz)   tar -C "$LLVM_MINGW_DIR" --strip-components=1 -xJf  "$f" ;;
            *.tar.zst|*.tzst) tar -C "$LLVM_MINGW_DIR" --strip-components=1 --zstd -xvf "$f" ;;
            *.tar.gz|*.tgz)   tar -C "$LLVM_MINGW_DIR" --strip-components=1 -xzf  "$f" ;;
            *) echo "::error::Unknown archive format: $url"; exit 1 ;;
          esac

          # PATH: 다음 스텝 + 현재 스텝 둘 다 반영
          echo "$LLVM_MINGW_DIR/bin" >> "$GITHUB_PATH"
          export PATH="$LLVM_MINGW_DIR/bin:$PATH"
          hash -r

          # 필수 바이너리 확인 (x86_64 프론트엔드 + i686)
          need=(x86_64-w64-mingw32-clang x86_64-w64-mingw32-clang++ i686-w64-mingw32-clang i686-w64-mingw32-clang++)
          for b in "${need[@]}"; do
            command -v "$b" >/dev/null || { echo "::error::missing tool: $b"; exit 1; }
          done

          # windres 후보 확인 (래퍼 없이 직접 사용)
          if command -v arm64ec-w64-mingw32-windres >/dev/null 2>&1; then
            echo "ARM64EC_WINDRES=arm64ec-w64-mingw32-windres" >> "$GITHUB_ENV"
            echo "ARM64EC_WINDRES_NEEDS_FLAG=false" >> "$GITHUB_ENV"
          elif command -v x86_64-w64-mingw32-windres >/dev/null 2>&1; then
            echo "ARM64EC_WINDRES=x86_64-w64-mingw32-windres" >> "$GITHUB_ENV"
            echo "ARM64EC_WINDRES_NEEDS_FLAG=true" >> "$GITHUB_ENV"
          else
            if command -v llvm-rc >/dev/null 2>&1; then
              echo "ARM64EC_WINDRES=llvm-rc" >> "$GITHUB_ENV"
              echo "ARM64EC_WINDRES_NEEDS_FLAG=false" >> "$GITHUB_ENV"
              echo "::warning::Using llvm-rc for ARM64EC .rc — may fail; prefer *-windres"
            else
              echo "::error::No windres found (need arm64ec-w64-mingw32-windres or x86_64-w64-mingw32-windres or llvm-rc)"; exit 1
            fi
          fi

      - name: Pin or stub ARM64EC helper (__icall_helper_arm64ec)
        run: |
          set -Eeuo pipefail
          # 최신 clang windows lib 디렉터리
          ARM_WIN_DIR="$(ls -d "$LLVM_MINGW_DIR"/lib/clang/*/lib/windows | LC_ALL=C sort -V | tail -n1)"
          [ -d "$ARM_WIN_DIR" ] || { echo "::error::No clang windows lib dir found"; exit 1; }

          # arm64ec 관련 .a 전수검사로 심볼 탐색
          HELPER=""
          while IFS= read -r lib; do
            if llvm-nm -g --defined-only "$lib" 2>/dev/null | grep -qi '__icall_helper_arm64ec'; then
              HELPER="$lib"; break
            fi
          done < <(find "$ARM_WIN_DIR" -maxdepth 1 -type f -name '*arm64ec*.a' -print | LC_ALL=C sort)

          if [ -n "$HELPER" ]; then
            echo "ARM_WIN_DIR=$ARM_WIN_DIR" >> "$GITHUB_ENV"
            echo "ARM64EC_LINK_WITH=$HELPER" >> "$GITHUB_ENV"
            echo "ARM64EC_LINK_KIND=lib" >> "$GITHUB_ENV"
            echo "Pinned helper: $HELPER"
          else
            echo "::warning::__icall_helper_arm64ec not found in $ARM_WIN_DIR — creating build-only stub object."
            cat > "$GITHUB_WORKSPACE/arm64ec_icall_helper.c" <<'EOF'
            /* build-only stub to satisfy linker; does not implement runtime semantics */
            #ifdef __cplusplus
            extern "C" {
            #endif
            void __icall_helper_arm64ec(void) { }
            #ifdef __cplusplus
            }
            #endif
            EOF
            x86_64-w64-mingw32-clang -c -o "$GITHUB_WORKSPACE/arm64ec_icall_helper.obj" "$GITHUB_WORKSPACE/arm64ec_icall_helper.c"
            echo "ARM_WIN_DIR=$ARM_WIN_DIR" >> "$GITHUB_ENV"
            echo "ARM64EC_LINK_WITH=$GITHUB_WORKSPACE/arm64ec_icall_helper.obj" >> "$GITHUB_ENV"
            echo "ARM64EC_LINK_KIND=obj" >> "$GITHUB_ENV"
          fi

      - name: Clone DXVK-Sarek (main + submodules)
        run: |
          set -Eeuo pipefail
          git clone --recurse-submodules "https://github.com/${SAREK_REPO}.git" src
          cd src
          git fetch --force
          git checkout -f main
          git submodule update --init --recursive --checkout

      - name: Create Meson cross files (ARM64EC & i686) — link helper or stub
        working-directory: src
        run: |
          set -Eeuo pipefail

          ARM_INC="$LLVM_MINGW_DIR/arm64ec-w64-mingw32/include"
          ARM_LIB="$LLVM_MINGW_DIR/arm64ec-w64-mingw32/lib"
          ARM_WIN_DIR="${ARM_WIN_DIR:?}"
          ARM64EC_LINK_WITH="${ARM64EC_LINK_WITH:?}"

          # windres 라인 구성
          if [ "${ARM64EC_WINDRES_NEEDS_FLAG:-false}" = "true" ]; then
            WINDRES_LINE="['${ARM64EC_WINDRES}', '-F', 'pe-arm64ec']"
          else
            WINDRES_LINE="'${ARM64EC_WINDRES}'"
          fi

          # 공통 링크 인자(+ 헬퍼 또는 스텁 오브젝트 절대경로)
          ARM_LINK_EXTRA="['-Wl,/machine:arm64ec','-L','${ARM_LIB}','-L','${ARM_WIN_DIR}','${ARM64EC_LINK_WITH}']"

          # ARM64EC (x86_64 프론트엔드 컴파일, ARM64EC 링크)
          cat > cross-arm64ec.txt <<EOF
          [binaries]
          c = 'x86_64-w64-mingw32-clang'
          cpp = 'x86_64-w64-mingw32-clang++'
          ar = 'llvm-ar'
          windres = ${WINDRES_LINE}
          strip = 'llvm-strip'
          pkg-config = 'pkg-config'

          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'

          [built-in options]
          c_args = ['-Wno-nontrivial-memcall','-Wno-macro-redefined','-Wno-dll-attribute-on-redeclaration','-D__ARM64EC__=1','-D_M_ARM64EC=1','-isystem','${ARM_INC}']
          cpp_args = ['-Wno-nontrivial-memcall','-Wno-macro-redefined','-Wno-dll-attribute-on-redeclaration','-D__ARM64EC__=1','-D_M_ARM64EC=1','-isystem','${ARM_INC}']
          c_link_args = ${ARM_LINK_EXTRA}
          cpp_link_args = ${ARM_LINK_EXTRA}
          EOF

          # i686
          cat > cross-i686.txt <<'EOF'
          [binaries]
          c = 'i686-w64-mingw32-clang'
          cpp = 'i686-w64-mingw32-clang++'
          ar = 'i686-w64-mingw32-ar'
          windres = 'i686-w64-mingw32-windres'
          strip = 'llvm-strip'
          pkg-config = 'pkg-config'

          [host_machine]
          system = 'windows'
          cpu_family = 'x86'
          cpu = 'i686'
          endian = 'little'

          [built-in options]
          c_args = ['-Wno-nontrivial-memcall','-Wno-macro-redefined','-Wno-dll-attribute-on-redeclaration']
          cpp_args = ['-Wno-nontrivial-memcall','-Wno-macro-redefined','-Wno-dll-attribute-on-redeclaration']
          EOF

          # i686 windres 없으면 llvm-rc로 대체
          if ! command -v i686-w64-mingw32-windres >/dev/null 2>&1 && command -v llvm-rc >/dev/null 2>&1; then
            sed -i "s|^windres = .*|windres = 'llvm-rc'|" cross-i686.txt
          fi

      - name: Build ARM64EC (DLLs)
        working-directory: src
        env:
          PREFIX_ARM64EC: ${{ github.workspace }}/dist-arm64ec
        run: |
          set -Eeuo pipefail
          meson setup "$GITHUB_WORKSPACE/build.arm64ec" \
            --cross-file cross-arm64ec.txt \
            --buildtype release \
            --prefix "$PREFIX_ARM64EC" \
            -Dbuild_id=false -Dstrip=true
          ninja -C "$GITHUB_WORKSPACE/build.arm64ec" -j"$(nproc)"
          meson install --no-rebuild -C "$GITHUB_WORKSPACE/build.arm64ec"

      - name: Build i686 (DLLs)
        working-directory: src
        env:
          PREFIX_I686: ${{ github.workspace }}/dist-i686
        run: |
          set -Eeuo pipefail
          meson setup "$GITHUB_WORKSPACE/build.i686" \
            --cross-file cross-i686.txt \
            --buildtype release \
            --prefix "$PREFIX_I686" \
            -Dbuild_id=false -Dstrip=true
          ninja -C "$GITHUB_WORKSPACE/build.i686" -j"$(nproc)"
          meson install --no-rebuild -C "$GITHUB_WORKSPACE/build.i686"

      - name: Collect DLLs
        run: |
          set -Eeuo pipefail
          mkdir -p out/arm64ec out/i686
          cp -v "$GITHUB_WORKSPACE"/dist-arm64ec/bin/*.dll out/arm64ec/ || true
          cp -v "$GITHUB_WORKSPACE"/dist-i686/bin/*.dll  out/i686/    || true

          echo "ARM64EC DLLs:"; ls -1 out/arm64ec || true
          echo "i686 DLLs:";   ls -1 out/i686   || true

          # 둘 다 비어 있으면 실패 처리
          if [ -z "$(find out/arm64ec -name '*.dll' -print -quit)" ] && \
             [ -z "$(find out/i686   -name '*.dll' -print -quit)" ]; then
            echo "::error::No DLLs produced"; exit 1
          fi

      - name: Upload artifact (arm64ec)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec
          path: out/arm64ec
          if-no-files-found: warn
          compression-level: 6

      - name: Upload artifact (i686)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-i686
          path: out/i686
          if-no-files-found: warn
          compression-level: 6
