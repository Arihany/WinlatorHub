name: Build DXVK-Sarek (arm64ec + i686) — DLL quick test

on:
  workflow_dispatch:

permissions:
  contents: read

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

jobs:
  build:
    runs-on: ubuntu-24.04
    timeout-minutes: 60
    env:
      SAREK_REPO: pythonlover02/DXVK-Sarek
      LLVM_MINGW_DIR: ${{ github.workspace }}/.toolchains/llvm-mingw
      OUT_DIR: ${{ github.workspace }}/out

    steps:
      - name: Install host deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            curl xz-utils zstd jq ca-certificates \
            git meson ninja-build pkg-config \
            glslang-tools llvm binutils python3 file

          # glslang 래퍼 (glslangValidator만 있을 때 --vn 지원용)
          if command -v glslangValidator >/dev/null && ! command -v glslang >/dev/null; then
            BIN="$HOME/.local/bin"; mkdir -p "$BIN"
            ln -sf "$(command -v glslangValidator)" "$BIN/glslang"
            echo "$BIN" >> "$GITHUB_PATH"
          fi

      - name: Download bylaws llvm-mingw (Ubuntu 20.04 x86_64 only)
        env:
          API: https://api.github.com/repos/bylaws/llvm-mingw/releases/latest
        run: |
          mkdir -p "$LLVM_MINGW_DIR"
          json="$(curl -fsSL -H 'Accept: application/vnd.github+json' "$API")"

          # 이 저장소는 22.04 자산이 없으므로 20.04만 검색
          url="$(echo "$json" | jq -r '.assets[] | select(.name|test("ucrt-ubuntu-20\\.04-x86_64\\.tar\\.xz$")) .browser_download_url' | head -n1)"
          [ -n "$url" ] || { echo "::error::llvm-mingw 20.04 x86_64 asset not found"; exit 1; }

          echo "Chosen: $url"
          f=/tmp/llvm-mingw.tar.xz
          curl -fL "$url" -o "$f"
          tar -C "$LLVM_MINGW_DIR" --strip-components=1 -xJf "$f"

          echo "$LLVM_MINGW_DIR/bin" >> "$GITHUB_PATH"
          export PATH="$LLVM_MINGW_DIR/bin:$PATH"
          hash -r

          # 필수 바이너리(래퍼 포함) 점검
          need=(clang clang++ llvm-rc llvm-ar llvm-nm llvm-readobj)
          for b in "${need[@]}"; do
            command -v "$b" >/dev/null || { echo "::error::missing tool: $b"; exit 1; }
          done

          # 있으면 래퍼 사용, 없으면 --target으로 폴백
          if command -v arm64ec-w64-mingw32-clang++ >/dev/null; then
            echo "USE_ARM64EC_WRAPPER=true" >> "$GITHUB_ENV"
          else
            echo "USE_ARM64EC_WRAPPER=false" >> "$GITHUB_ENV"
            echo "::warning::arm64ec-w64-mingw32-clang++ not found — will use clang++ --target=arm64ec-w64-mingw32 with -isystem fallback."
          fi

          if command -v i686-w64-mingw32-clang++ >/dev/null; then
            echo "USE_I686_WRAPPER=true" >> "$GITHUB_ENV"
          else
            echo "USE_I686_WRAPPER=false" >> "$GITHUB_ENV"
            echo "::error::i686-w64-mingw32-clang++ not found"; exit 1
          fi

          # windres 후보 (ARM64EC)
          if command -v arm64ec-w64-mingw32-windres >/dev/null 2>&1; then
            echo "ARM64EC_WINDRES=arm64ec-w64-mingw32-windres" >> "$GITHUB_ENV"
            echo "ARM64EC_WINDRES_NEEDS_FLAG=false" >> "$GITHUB_ENV"
          elif command -v x86_64-w64-mingw32-windres >/dev/null 2>&1; then
            echo "ARM64EC_WINDRES=x86_64-w64-mingw32-windres" >> "$GITHUB_ENV"
            echo "ARM64EC_WINDRES_NEEDS_FLAG=true" >> "$GITHUB_ENV"
          elif command -v llvm-rc >/dev/null 2>&1; then
            echo "ARM64EC_WINDRES=llvm-rc" >> "$GITHUB_ENV"
            echo "ARM64EC_WINDRES_NEEDS_FLAG=false" >> "$GITHUB_ENV"
            echo "::warning::Using llvm-rc for ARM64EC .rc — prefer *-windres"
          else
            echo "::error::No windres/llvm-rc found for ARM64EC"; exit 1
          fi

          # windres 후보 (i686)
          if command -v i686-w64-mingw32-windres >/dev/null 2>&1; then
            echo "I686_WINDRES=i686-w64-mingw32-windres" >> "$GITHUB_ENV"
          elif command -v llvm-rc >/dev/null 2>&1; then
            echo "I686_WINDRES=llvm-rc" >> "$GITHUB_ENV"
          else
            echo "::error::No windres/llvm-rc found for i686"; exit 1
          fi

      - name: Detect libc++ headers (fallback only)
        id: cxx
        run: |
          set -Eeuo pipefail
          CXX_INCLUDE=""
          for d in "$LLVM_MINGW_DIR/include/c++/v1" "$LLVM_MINGW_DIR/arm64ec-w64-mingw32/include/c++/v1"; do
            if [ -d "$d" ]; then CXX_INCLUDE="$d"; break; fi
          done
          [ -n "$CXX_INCLUDE" ] && echo "CXX_INCLUDE=$CXX_INCLUDE" >> "$GITHUB_OUTPUT" || true
          echo "Detected C++ include (fallback): ${CXX_INCLUDE:-<none>}"

      - name: Locate ARM64EC helper (libclang_rt.builtins-arm64ec.a)
        id: helper
        run: |
          set -Eeuo pipefail
          ARM_WIN_DIR="$(ls -d "$LLVM_MINGW_DIR"/lib/clang/*/lib/windows | LC_ALL=C sort -V | tail -n1)"
          [ -d "$ARM_WIN_DIR" ] || { echo "::error::No clang windows lib dir found"; exit 1; }
          HELPER="$ARM_WIN_DIR/libclang_rt.builtins-arm64ec.a"
          [ -f "$HELPER" ] || { echo "::error::missing $HELPER"; exit 1; }
          echo "ARM_WIN_DIR=$ARM_WIN_DIR" >> "$GITHUB_OUTPUT"
          echo "HELPER=$HELPER" >> "$GITHUB_OUTPUT"
          echo "nm check (optional):"
          llvm-nm -g "$HELPER" | grep -E '__icall_helper_arm64ec' || echo "(symbol not listed but archive will be force-included)"

      - name: Clone DXVK-Sarek (main + submodules)
        run: |
          git clone --recurse-submodules "https://github.com/${SAREK_REPO}.git" src
          cd src
          git fetch --force origin main
          git checkout -f origin/main
          git submodule update --init --recursive --checkout

      - name: Write ARM64EC pre-include header (nuke x86 macros, assert ARM64/EC)
        run: |
          set -Eeuo pipefail
          cat > "$GITHUB_WORKSPACE/arm64ec-preinclude.h" <<'EOF'
          #ifndef ARM64EC_PREINCLUDE_GUARD
          #define ARM64EC_PREINCLUDE_GUARD 1
          /* x86/x64 매크로 전부 끄기 */
          #ifdef __i386__      /* GCC/Clang i386 */   #undef __i386__    #endif
          #ifdef __i386        /* 변형 */             #undef __i386      #endif
          #ifdef _M_IX86                                  #undef _M_IX86   #endif
          #ifdef _X86_                                     #undef _X86_    #endif
          #ifdef __x86_64__                                #undef __x86_64__ #endif
          #ifdef __x86_64                                  #undef __x86_64 #endif
          #ifdef __amd64__                                 #undef __amd64__ #endif
          #ifdef __amd64                                   #undef __amd64  #endif
          #ifdef _M_X64                                    #undef _M_X64   #endif
          #ifdef _M_AMD64                                  #undef _M_AMD64 #endif
          #ifdef _AMD64_                                   #undef _AMD64_  #endif
          /* ARM64/EC 매크로 명시적으로 켜기 */
          #ifndef __aarch64__  #define __aarch64__ 1  #endif
          #ifndef _M_ARM64     #define _M_ARM64  1    #endif
          #ifndef __ARM64EC__  #define __ARM64EC__ 1  #endif
          #ifndef _M_ARM64EC   #define _M_ARM64EC 1   #endif
          #ifndef __CHPE__     #define __CHPE__ 1     #endif
          /* 보수적 안전핀: 일부 mingw 헤더의 인라인 ASM 경로 비활성화 */
          #ifndef __NO_INLINE__ #define __NO_INLINE__ 1 #endif
          #endif /* ARM64EC_PREINCLUDE_GUARD */
          EOF
          ls -l "$GITHUB_WORKSPACE/arm64ec-preinclude.h"

      - name: Write Meson cross file (ARM64EC) — enforce preinclude & macros
        working-directory: src
        env:
          USE_ARM64EC_WRAPPER: ${{ env.USE_ARM64EC_WRAPPER }}
        run: |
          set -Eeuo pipefail
          ARM_WIN_DIR='${{ steps.helper.outputs.ARM_WIN_DIR }}'
          HELPER='${{ steps.helper.outputs.HELPER }}'
          PREINC="$GITHUB_WORKSPACE/arm64ec-preinclude.h"
      
          # windres 커맨드
          if [ "${ARM64EC_WINDRES_NEEDS_FLAG:-false}" = "true" ]; then
            WINDRES_LINE="['${ARM64EC_WINDRES}','-F','pe-arm64ec']"
          else
            WINDRES_LINE="'${ARM64EC_WINDRES}'"
          fi
      
          # 래퍼/폴백
          if [ "${USE_ARM64EC_WRAPPER}" = "true" ]; then
            CBIN="['arm64ec-w64-mingw32-clang']"
            CXXBIN="['arm64ec-w64-mingw32-clang++']"
            CARGS="[]"; CPARGS="[]"
          else
            CBIN="['clang','--target=arm64ec-w64-mingw32']"
            CXXBIN="['clang++','--target=arm64ec-w64-mingw32']"
            if [ -n "${{ steps.cxx.outputs.CXX_INCLUDE }}" ]; then
              CARGS="['-isystem','${{ steps.cxx.outputs.CXX_INCLUDE }}']"
              CPARGS="$CARGS"
            else
              CARGS="[]"; CPARGS="[]"
            fi
          fi
      
          # 💡 한 줄로! (줄바꿈/역슬래시 절대 없음)
          EXTRA_ARGS="['-include','${PREINC}','-D__aarch64__=1','-D_M_ARM64=1','-D__ARM64EC__=1','-D_M_ARM64EC=1','-D__CHPE__=1','-Wno-macro-redefined','-Wno-dll-attribute-on-redeclaration','-Wno-nontrivial-memcall']"
      
          merge_arrays () {
            local a="$1" b="$2"
            a="${a#[}" ; a="${a%]}"
            b="${b#[}" ; b="${b%]}"
            if [ -z "$a" ]; then
              [ -z "$b" ] && echo "[]" || echo "[$b]"
            else
              [ -z "$b" ] && echo "[$a]" || echo "[$a,$b]"
            fi
          }
          CARGS="$(merge_arrays "$CARGS" "$EXTRA_ARGS")"
          CPARGS="$(merge_arrays "$CPARGS" "$EXTRA_ARGS")"
      
          cat > cross.arm64ec.ini <<EOF
          [binaries]
          c = ${CBIN}
          cpp = ${CXXBIN}
          ar = 'llvm-ar'
          strip = 'llvm-strip'
          windres = ${WINDRES_LINE}
          pkg-config = 'pkg-config'
      
          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
      
          [built-in options]
          c_args = ${CARGS}
          cpp_args = ${CPARGS}
          c_link_args = ['-fuse-ld=lld','-Wl,/machine:arm64ec','-Wl,--whole-archive,${HELPER},--no-whole-archive','-L','${ARM_WIN_DIR}']
          cpp_link_args = ['-fuse-ld=lld','-Wl,/machine:arm64ec','-Wl,--whole-archive,${HELPER},--no-whole-archive','-L','${ARM_WIN_DIR}']
          EOF
      
          echo "### cross.arm64ec.ini"
          cat cross.arm64ec.ini

      - name: Write Meson cross file (i686)
        working-directory: src
        run: |
          set -Eeuo pipefail
          # i686 windres
          if [ -n "${I686_WINDRES:-}" ]; then
            WINDRES_LINE="'${I686_WINDRES}'"
          else
            WINDRES_LINE="'llvm-rc'"
          fi

          cat > cross.i686.ini <<EOF
          [binaries]
          c = 'i686-w64-mingw32-clang'
          cpp = 'i686-w64-mingw32-clang++'
          ar = 'llvm-ar'
          strip = 'llvm-strip'
          windres = ${WINDRES_LINE}
          pkg-config = 'pkg-config'

          [host_machine]
          system = 'windows'
          cpu_family = 'x86'
          cpu = 'i686'
          endian = 'little'

          [built-in options]
          c_args = []
          cpp_args = []
          c_link_args = ['-fuse-ld=lld']
          cpp_link_args = ['-fuse-ld=lld']
          EOF

          echo "### cross.i686.ini"
          cat cross.i686.ini

      - name: Build (ARM64EC)
        working-directory: src
        env:
          PREFIX: ${{ env.OUT_DIR }}/arm64ec
        run: |
          rm -rf build.arm64ec "$PREFIX"
          meson setup build.arm64ec \
            --cross-file cross.arm64ec.ini \
            --buildtype release \
            --prefix "$PREFIX" \
            -Dbuild_id=false -Dstrip=true
          ninja -C build.arm64ec -j"$(nproc)"
          meson install --no-rebuild -C build.arm64ec

          echo "== verify PE headers (ARM64EC) =="
          find "$PREFIX/bin" -name '*.dll' -print0 | xargs -0 -I{} sh -c 'echo "# {}"; llvm-readobj -file-headers "{}" | sed -n "1,40p"'

      - name: Build (i686)
        working-directory: src
        env:
          PREFIX: ${{ env.OUT_DIR }}/i686
        run: |
          rm -rf build.i686 "$PREFIX"
          meson setup build.i686 \
            --cross-file cross.i686.ini \
            --buildtype release \
            --prefix "$PREFIX" \
            -Dbuild_id=false -Dstrip=true
          ninja -C build.i686 -j"$(nproc)"
          meson install --no-rebuild -C build.i686

      - name: Collect & list DLLs
        run: |
          set -Eeuo pipefail
          mkdir -p "$OUT_DIR/zips"
          echo "ARM64EC DLLs:"; ls -1 "$OUT_DIR/arm64ec/bin"/*.dll 2>/dev/null || true
          echo "i686 DLLs:";   ls -1 "$OUT_DIR/i686/bin"/*.dll    2>/dev/null || true

          if [ -z "$(find "$OUT_DIR/arm64ec/bin" -name '*.dll' -print -quit)" ] && \
             [ -z "$(find "$OUT_DIR/i686/bin"    -name '*.dll' -print -quit)" ]; then
            echo "::error::No DLLs produced"; exit 1
          fi

          tar -C "$OUT_DIR/arm64ec/bin" -czf "$OUT_DIR/zips/dxvk-sarek-arm64ec-dlls.tgz" . 2>/dev/null || true
          tar -C "$OUT_DIR/i686/bin"    -czf "$OUT_DIR/zips/dxvk-sarek-i686-dlls.tgz"    . 2>/dev/null || true

      - name: Upload ARM64EC DLLs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-arm64ec-dlls
          path: ${{ env.OUT_DIR }}/zips/dxvk-sarek-arm64ec-dlls.tgz
          if-no-files-found: warn
          compression-level: 6

      - name: Upload i686 DLLs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dxvk-sarek-i686-dlls
          path: ${{ env.OUT_DIR }}/zips/dxvk-sarek-i686-dlls.tgz
          if-no-files-found: warn
          compression-level: 6
